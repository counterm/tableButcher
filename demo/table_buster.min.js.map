{"version":3,"sources":["father.js","mother.js","liLei.js","hanMeiMei.js","puppy.js","home.js"],"names":["split","td","decorater","getSpan","spanRow","spanCol","rowSpan","colSpan","spanIndexCol","after","document","createElement","spanIndexRow","arrTdIndex","getTdIndex","arrTdMatrix","getTdMatrix","tr","parentNode","childNodes","tds","firstTdMatrix","length","Number","MAX_VALUE","appendChild","index","tdFound","tdFoundMatrix","before","refresh","deleteColumn","tdColCount","tdColMatrix","tdColSpan","deleteColumnHandler","rowIndex","tdDone","tbSize","getSize","getTdByMatrix","indexOf","removeChild","push","deleteRow","tdRowCount","tdRowMatrix","tdRowSpan","deleteRowHandler","colIndex","dom","nextTr","nextElementSibling","tdMarkShort","cellType","CELL_BIG_HEAD","nextTdColMatrix","nextRowTd","CELL_BIG","forEach","merge","tdFrom","tdTo","selectionTd","selectionByTd","arrTdInArea","area","matFrom","matTo","firstTd","shift","node","append","findAreaTd","selection","queue","tdFromPosition","getMatRectangeAreaByTd","tdFromAndEndPosition","me","matrixForInArea","num","newFound","newArea","concat","tdArea","cellCanCount","findFirstNumberPosition","sort","CELL_NORMAL","matrix","buildMatrix","sizeRow","sizeCol","tmpRow","maxFillNumber","arr","Array","from","repeat","map","v","forEachCell","matrixTd2Mat","matRow","matCol","fillBigInMat","matrixFor","fn","row","col","ret","rowLoop","Math","min","max","colLoop","iRow","iCol","tdRow","tdCol","matRowArr","tdColIndex","retMatCol","expNumber","matColIndex","matrixMat2Td","loopColIndex","startMatRow","startMatCol","cellSpan","indexRow","m","indexCol","endRow","endCol","matRowOrTd","number","HTMLTableCellElement","arguments","tmpNum","targetNum","getBigCellSize","startNumber","startPos","numberSearch","maxRowBefore","maxColBefore","arrTd","arrMat","getMatRectangeArea","mats","mat","areaJoin","pop","addRow","forEachRow","insertRow","beforeTd","tdRowIndex","sizeCell","fnAddTd","trHolder","sizeIndex","size","addCell","colCount","rowCount","newTr","insertCell","beforeThisTd","tableClassName","init","table","querySelectorAll","val","getTdByIndex","inRow","allTdSize","thisRowSize","span","a","b","aPos","bPos","forUnderTable","selector","elements","forEachMatrix","indexOfRow","indexOfCol","findFirstTime","diapason","father","mother","liLei","hanMeiMei","puppy","TableBuster","prototype","window"],"mappings":"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","file":"table_buster.min.js","sourceRoot":"..\\src","sourcesContent":["// strong man\r\n/*\r\n\r\n*/\r\nexport default {\r\n    split(td, decorater) {\r\n        if (!td) return;\r\n        if (!decorater) decorater = (td) => td;\r\n        let [spanRow, spanCol] = this.getSpan(td);\r\n        if (spanRow > 1 || spanCol > 1) {\r\n            td.rowSpan = 1;\r\n            td.colSpan = 1;\r\n            // row 1\r\n            let spanIndexCol = spanCol - 1;\r\n            while (spanIndexCol > 0) {\r\n                td.after(decorater(document.createElement('td'), 0,  spanIndexCol - 1));\r\n                spanIndexCol--;\r\n            }\r\n            // other row\r\n            let spanIndexRow = spanRow - 1 - 1;\r\n            const arrTdIndex = this.getTdIndex(td);\r\n            const arrTdMatrix = this.getTdMatrix(td);\r\n            while (spanIndexRow >= 0) {\r\n                spanIndexCol = spanCol - 1;\r\n                const tr = td.parentNode.parentNode.childNodes[arrTdIndex[0] + (spanRow - 1 - spanIndexRow)];\r\n                const tds = tr.childNodes;\r\n                const firstTdMatrix = tds.length > 0 ? this.getTdMatrix(tds[0]) : Number.MAX_VALUE;\r\n                /*\r\n                    1. The td ready to merge was on the first cell index.\r\n                    2. The row was empty.\r\n                    3. The first td in the row must be after the td which ready to insert.\r\n                 */\r\n                if (arrTdMatrix[0] == 0 && tds.length == 0 && firstTdMatrix[1] <= arrTdMatrix[1]) {\r\n                    while (spanIndexCol >= 0) {\r\n                        tr.appendChild(decorater(document.createElement('td'), spanRow - 1 - spanIndexRow, spanCol - 1 - spanIndexCol));\r\n                        spanIndexCol--;\r\n                    }\r\n                } else {\r\n                    for (let index = 0; index < tds.length; index++) {\r\n                        const tdFound = tds[index];\r\n                        const tdFoundMatrix = this.getTdMatrix(tdFound);\r\n                        if (tdFoundMatrix[1] > arrTdMatrix[1]) {\r\n                            while (spanIndexCol >= 0) {\r\n                                tdFound.before(decorater(document.createElement('td'), spanRow - 1 - spanIndexRow, spanCol - 1 - spanIndexCol));\r\n                                spanIndexCol--;\r\n                            }\r\n                            break;\r\n                        } else if (index + 1 == tds.length) {   // last position\r\n                            while (spanIndexCol >= 0) {\r\n                                tdFound.after(decorater(document.createElement('td'), spanRow - 1 - spanIndexRow, spanIndexCol - 1));\r\n                                spanIndexCol--;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                spanIndexRow--;\r\n            }\r\n        }\r\n        this.refresh();\r\n    },\r\n\r\n    deleteColumn(td) {\r\n        if (!td) return;\r\n        // const size = td.colSpan;\r\n        const [tdRowMatrix, tdColMatrix] = this.getTdMatrix(td);\r\n        const tdColSpan = td.colSpan;\r\n        let tdColCount = 0;\r\n\r\n        while (tdColCount < tdColSpan) {\r\n            this.deleteColumnHandler(tdColMatrix);\r\n            this.refresh();\r\n            tdColCount++;\r\n        }\r\n    },\r\n\r\n    deleteColumnHandler(tdColMatrix) {\r\n        const tdDone = [];\r\n        const tbSize = this.getSize();\r\n        let rowIndex = 0;\r\n\r\n        while (rowIndex < tbSize[0]) {\r\n            const tdFound = this.getTdByMatrix(rowIndex, tdColMatrix);\r\n            if (tdFound && tdDone.indexOf(tdFound) == -1) {\r\n                if (tdFound.colSpan > 1) {\r\n                    tdFound.colSpan -= 1;\r\n                } else {\r\n                    tdFound.parentNode.removeChild(tdFound);\r\n                }\r\n                tdDone.push(tdFound);\r\n                // fix some td rowSpan greater than 1, and delete wrong TDs in the next row.\r\n                if (tdFound.rowSpan > 1) {\r\n                    rowIndex += tdFound.rowSpan;\r\n                    continue;\r\n                }\r\n            }\r\n            rowIndex++;\r\n        }\r\n    },\r\n    \r\n    deleteRow(td) {\r\n        if (!td) return;\r\n        // const tr = td.parentNode;\r\n        const [tdRowMatrix, tdColMatrix] = this.getTdMatrix(td);\r\n\r\n        const tdRowSpan = td.rowSpan;\r\n        let tdRowCount = 0;\r\n        while (tdRowCount < tdRowSpan) {\r\n            this.deleteRowHandler(tdRowMatrix);\r\n            this.refresh();\r\n            tdRowCount++;\r\n        }\r\n    },\r\n\r\n    deleteRowHandler(tdRowMatrix) {\r\n        const tr = this.dom.childNodes[0].childNodes[tdRowMatrix];\r\n        const nextTr = tr.nextElementSibling;\r\n        const tbSize = this.getSize();\r\n        let colIndex = 0;\r\n        const tdMarkShort = [];\r\n        while (colIndex < tbSize[1]) {\r\n            const cellType = this.cellType(tdRowMatrix, colIndex);\r\n\r\n            // \r\n            if (cellType == this.CELL_BIG_HEAD) {\r\n                const tdFound = this.getTdByMatrix(tdRowMatrix, colIndex);\r\n                // move tdFound to next tr\r\n                if (tdFound.rowSpan > 1 && tbSize[0] != tdRowMatrix) {\r\n                    let nextTdColMatrix = colIndex + tdFound.colSpan;\r\n                    while (nextTdColMatrix < tbSize[1]) {\r\n                        const nextRowTd = this.getTdByMatrix(tdRowMatrix + 1, nextTdColMatrix);\r\n                        if (nextRowTd.parentNode == nextTr) {\r\n                            nextRowTd.before(tdFound);\r\n                            break;\r\n                        }\r\n                        nextTdColMatrix++;\r\n                    }\r\n                    if (tdFound.parentNode != nextTr) {\r\n                        nextTr.appendChild(tdFound);\r\n                    }\r\n                    // make sure short it.\r\n                    tdFound.rowSpan--;\r\n                    this.refresh();\r\n                }\r\n\r\n                colIndex += tdFound.colSpan;\r\n            } else if(cellType == this.CELL_BIG) {\r\n                const tdFound = this.getTdByMatrix(tdRowMatrix, colIndex);\r\n                tdMarkShort.push(tdFound);\r\n                this.refresh()\r\n                colIndex += tdFound.colSpan;\r\n            } else {\r\n                colIndex++;\r\n            }\r\n        }\r\n        tdMarkShort.forEach((td) => td.rowSpan--);\r\n        tr.parentNode.removeChild(tr);\r\n    }\r\n};","// merge, nice women\r\nexport default {\r\n    /**\r\n     * \r\n     * @param {Element} tdFrom \r\n     * @param {Element} tdTo \r\n     */\r\n    merge(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let selectionTd = this.selectionByTd(tdFrom, tdTo),\r\n            arrTdInArea = selectionTd.td,\r\n            [matFrom, matTo] = selectionTd.area,\r\n            rowSpan = matTo[0] - matFrom[0] + 1,\r\n            colSpan = matTo[1] - matFrom[1] + 1,\r\n            firstTd = arrTdInArea.shift();\r\n        \r\n        // remove node\r\n        arrTdInArea.forEach((td, index)=>{\r\n            if (td.childNodes.length > 0){\r\n                // swap node\r\n                td.childNodes.forEach((node, index)=>{\r\n                    firstTd.append(node);\r\n                })\r\n            }\r\n            td.parentNode.removeChild(td);\r\n        });\r\n\r\n        // merge node\r\n        firstTd.rowSpan = rowSpan;\r\n        firstTd.colSpan = colSpan;\r\n\r\n        this.refresh();\r\n    },\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {Element} tdFrom \r\n     * @param {Element} tdTo \r\n     */\r\n    findAreaTd(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let selection = this.selectionByTd(tdFrom, tdTo);\r\n        return selection.td;\r\n    },\r\n\r\n\r\n\r\n\r\n    /**\r\n     * All TDs in rectange selection.\r\n     * @param {Element} tdFrom\r\n     * @param {Element} tdTo\r\n     */\r\n    selectionByTd(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let queue = [tdFrom, tdTo],\r\n            index = 0,\r\n            tdFromPosition = this.getMatRectangeAreaByTd(tdFrom),\r\n            tdFromAndEndPosition = this.getMatRectangeAreaByTd(tdFrom, tdTo),\r\n            area = [\r\n                tdFromPosition[0][0], tdFromPosition[0][1],  // left top\r\n                tdFromPosition[1][0], tdFromPosition[1][1]   // right bottom\r\n            ],\r\n            me = this;\r\n\r\n\r\n        // find other TD inner area\r\n        // TODO: can be optimized.\r\n        this.matrixForInArea(\r\n            tdFromAndEndPosition[0], tdFromAndEndPosition[1], \r\n            (num, rowIndex, colIndex)=>{\r\n                let td = me.getTdByMatrix(rowIndex, colIndex);\r\n                if (queue.indexOf(td) == -1){\r\n                    queue.push(td);\r\n                }\r\n            }\r\n        );\r\n\r\n        // find big cell expand\r\n        while(index < queue.length){\r\n            let newFound = false,\r\n                newArea = area.concat(),\r\n                tdArea = this.getMatRectangeAreaByTd(queue[index]);\r\n\r\n            if (tdArea[0][0] < newArea[0]){\r\n                newArea[0] = tdArea[0][0];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[0][1] < newArea[1]){\r\n                newArea[1] = tdArea[0][1];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[1][0] > newArea[2]){\r\n                newArea[2] = tdArea[1][0];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[1][1] > newArea[3]){\r\n                newArea[3] = tdArea[1][1];\r\n                newFound = true;\r\n            }\r\n\r\n            if (newFound == true){\r\n                let me = this;\r\n                this.matrixForInArea(\r\n                    [newArea[0], newArea[1]],\r\n                    [newArea[2], newArea[3]],\r\n                    (num, rowIndex, colIndex)=>{\r\n                        if (rowIndex < area[0] || rowIndex > area[2] || colIndex < area[1] || colIndex > area[3]){ // out of the past area \r\n                            // find head unit of big cell\r\n                            if (me.cellCanCount(rowIndex, colIndex) == false){\r\n                                [rowIndex, colIndex] = me.findFirstNumberPosition(rowIndex, colIndex);\r\n                                if (rowIndex == -1 || colIndex == -1)\r\n                                    return;    \r\n                            }\r\n                            let td = me.getTdByMatrix(rowIndex, colIndex);\r\n                            if (queue.indexOf(td) == -1){\r\n                                queue.push(td);\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n                area = newArea;\r\n            }\r\n            index++;\r\n        }\r\n        queue = this.sort(queue);\r\n        return {td:queue, area: [[area[0], area[1]], [area[2], area[3]]]};\r\n    },\r\n\r\n};","// A creative boy\r\n// something about table matrix\r\nexport default {\r\n    /*\r\n\r\n    table expression\r\n    0 0 0\r\n    0 0 0\r\n    0 0 0\r\n\r\n    every number point to a td position.\r\n    0 is a normal td, other number is a large td's placehodler.\r\n    As a big cell, it place all the same number to mark the position, \r\n    except the first place. for example '3', first number will be '-3'.\r\n\r\n    example:\r\n    0 -1 1 0\r\n    0 1 1 0\r\n\r\n    <table>\r\n        <tr>\r\n            <td></td>\r\n            <td colspan=\"2\" rowspan=\"2\"></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n    </table>\r\n\r\n    */\r\n    CELL_NORMAL       : 0,\r\n    CELL_BIG          : 1,\r\n    CELL_BIG_HEAD     : 2,\r\n    matrix:[[]],\r\n    refresh(){\r\n        // let time = +new Date();\r\n        this.buildMatrix();\r\n        // console.log(`refresh time use: ${(+new Date() - time)}ms`);\r\n    },\r\n\r\n\r\n    buildMatrix(){\r\n        let [sizeRow, sizeCol] = this.getSize(),\r\n            tmpRow = sizeRow,\r\n            maxFillNumber = 1; \r\n        // fill zero at all\r\n        this.matrix = [];\r\n        while(tmpRow > 0){\r\n            const arr = Array.from('0'.repeat(sizeCol)).map(v => +v);\r\n            this.matrix.push(arr);\r\n            tmpRow--;\r\n        }\r\n        // recognize big cell\r\n        this.forEachCell((td, rowIndex, colIndex, tr) => {\r\n            let [rowSpan, colSpan] = this.getSpan(td);\r\n            let [matRow, matCol] = this.matrixTd2Mat(rowIndex, colIndex);\r\n            // checkout big cell and fill number\r\n            if (rowSpan > 1 || colSpan > 1){\r\n                // count actual column index\r\n                this.fillBigInMat(maxFillNumber, matRow, matCol, rowSpan, colSpan);\r\n                maxFillNumber++;\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * \r\n     * @param {Function} fn (number, rowIndex, colIndex)\r\n     */\r\n    matrixFor(fn){\r\n        let rowIndex = 0, colIndex = 0, ret;\r\n        for(let row of this.matrix){\r\n            colIndex = 0;\r\n            for(let col of row){\r\n                ret = fn(col, rowIndex, colIndex);\r\n                if(ret == true)\r\n                    return col;\r\n                colIndex++;\r\n            }\r\n            rowIndex++;\r\n        }\r\n    },\r\n\r\n\r\n    matrixForInArea(matFrom , matTo, fn){\r\n        let rowLoop = [Math.min(matFrom[0], matTo[0]), Math.max(matFrom[0], matTo[0])],\r\n            colLoop = [Math.min(matFrom[1], matTo[1]), Math.max(matFrom[1], matTo[1])];\r\n        \r\n        for(let iRow = rowLoop[0]; iRow <= rowLoop[1]; iRow++){\r\n            for(let iCol = colLoop[0]; iCol <= colLoop[1]; iCol++){\r\n                if (fn(this.matrix[iRow][iCol], iRow, iCol) === true){\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n\r\n    // change axis\r\n    matrixTd2Mat(tdRow, tdCol){\r\n        let matRow = tdRow,\r\n            matRowArr = this.matrix[tdRow],\r\n            tdColIndex = -1,\r\n            retMatCol = -1,\r\n            me = this;\r\n        matRowArr.forEach((expNumber, matColIndex)=>{\r\n            if (me.cellCanCount(matRow, matColIndex)){\r\n                tdColIndex++;\r\n            }\r\n            if (retMatCol == -1 && tdColIndex === tdCol){\r\n                retMatCol = matColIndex;\r\n            }\r\n        });\r\n        return [matRow, retMatCol];\r\n    },\r\n\r\n\r\n    // change axis\r\n    matrixMat2Td(matRow, matCol){\r\n        if (this.cellType(matRow, matCol) === this.CELL_BIG){\r\n            [matRow, matCol] = this.findFirstNumberPosition(matRow, matCol);\r\n        }\r\n        let loopColIndex = 0, \r\n            tdRow = matRow,\r\n            tdCol = -1;\r\n        while(loopColIndex <= matCol){\r\n            if (this.cellCanCount(matRow, loopColIndex)){\r\n                tdCol++;\r\n            } \r\n            loopColIndex++;\r\n        }\r\n        return [tdRow, tdCol];\r\n        // matrix number\r\n        // let number = this.matrix[matRow][matCol],\r\n        //     count = -1;\r\n        // if (this.cellCanCount(matRow, matCol)){\r\n        //     count++;\r\n        // }else{\r\n\r\n        // }\r\n        // try{\r\n        //     number = ;\r\n        // }catch(e){\r\n        //     console.log(`matrixMat2Td fail. ${matRow}, ${matCol} overload.`);\r\n        //     console.log(e);\r\n        //     return null;\r\n        // }\r\n\r\n    },\r\n\r\n\r\n\r\n    // in big cell area, fill number in it, except first number was multiply -1\r\n    fillBigInMat(expNumber, startMatRow, startMatCol, rowSpan, cellSpan){\r\n        let m = this.matrix;\r\n        let endRow = startMatRow + rowSpan - 1,\r\n            endCol = startMatCol + cellSpan - 1,\r\n            indexRow = startMatRow, \r\n            indexCol;\r\n        while(indexRow <= endRow){\r\n            indexCol = startMatCol;\r\n            while(indexCol <= endCol){\r\n                m[indexRow][indexCol] = expNumber;\r\n                indexCol++;\r\n            }\r\n            indexRow++;\r\n        }\r\n        // rewrite first number\r\n        m[startMatRow][startMatCol] = -1 * expNumber;\r\n    },\r\n\r\n\r\n    // return [0,1,2]\r\n    //   0: not a big cell\r\n    //   1: is a big cell, not the first place\r\n    //   2: is a big cell and is the first place\r\n    cellType(matRowOrTd, matCol){\r\n        let number = null, ret;\r\n        \r\n        if (matCol == null){\r\n            // argument was td\r\n            if (matRowOrTd instanceof HTMLTableCellElement){\r\n                [matRowOrTd, matCol] = this.matrixTd2Mat(...this.getTdIndex(matRowOrTd));\r\n            }else{ // argument was number\r\n                number = matRowOrTd;\r\n            }\r\n        }\r\n        \r\n        if (number == null && matCol != null){\r\n            number = this.matrix[matRowOrTd][matCol];\r\n        }\r\n\r\n        number = +number;\r\n        if (number == 0){\r\n            ret = this.CELL_NORMAL;\r\n        }else if(number > 0){\r\n            ret = this.CELL_BIG;\r\n        }else{\r\n            ret = this.CELL_BIG_HEAD;\r\n        }\r\n        \r\n        return ret;\r\n    },\r\n\r\n\r\n    // judge the cell single or belong to big cell for that can not be count.\r\n    cellCanCount(matRow, matCol){\r\n        let type = this.cellType(...arguments);\r\n        // If matrix unit number is not bigger than 0, it will specify to a true td.\r\n        if (this.CELL_BIG != this.cellType(matRow, matCol)){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * td in matrix return matrix number of the head\r\n     * @param {Array(x,y)} matRow \r\n     * @param {Array(x,y)} matCol \r\n     */\r\n    findFirstNumberPosition(matRow, matCol){\r\n        let m = this.matrix,\r\n            number = this.matrix[matRow][matCol];\r\n\r\n        if (this.CELL_BIG == this.cellType(matRow, matCol)){\r\n            let rowIndex = matRow,\r\n                colIndex = matCol,\r\n                tmpNum = m[rowIndex][colIndex],\r\n                targetNum = -1 * number;\r\n\r\n            // move left in row\r\n            while(colIndex >= 0){\r\n                tmpNum = m[rowIndex][colIndex];\r\n                if (tmpNum == targetNum){\r\n                    return [rowIndex, colIndex];\r\n                }else if(tmpNum == number){\r\n                    colIndex--;\r\n                }else{\r\n                    // our of range, move up.\r\n                    colIndex++;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            colIndex = colIndex < 0 ? 0 : colIndex;\r\n            rowIndex--;\r\n            \r\n            // move up in col\r\n            while(rowIndex >= 0){\r\n                tmpNum = m[rowIndex][colIndex];\r\n                if (tmpNum == targetNum){\r\n                    return [rowIndex, colIndex];\r\n                }else if(tmpNum == number){\r\n                    rowIndex--;\r\n                }else{\r\n                    // out of range\r\n                    break;\r\n                }\r\n            }\r\n            // can not found, return [-1, -1].\r\n            return [-1, -1]\r\n        }else{\r\n            return [matRow, matCol];\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * find cell in matrix axis, and recognize all cell area in matrix axis, \r\n     * return the start and end.\r\n     * @param {Array(x,y)} matRow \r\n     * @param {Array(x,y)} matCol \r\n     */\r\n    getBigCellSize(matRow, matCol){\r\n        let number = this.matrix[matRow][matCol],\r\n            startNumber;\r\n        let startPos = [], endPos = [];\r\n        if (this.cellType(number) == this.CELL_NORMAL){\r\n            return [[matRow, matCol], [matRow, matCol]];\r\n        }else if (this.cellType(number) == this.CELL_BIG_HEAD){\r\n            startNumber = number;\r\n            number = -1 * number;\r\n            startPos = [matRow, matCol];\r\n        }else{\r\n            startNumber = -1 * number;\r\n\r\n            // findout start position\r\n            this.matrixFor((numberSearch, rowIndex, colIndex)=>{\r\n                if (numberSearch == startNumber){\r\n                    startPos = [rowIndex, colIndex];\r\n                }\r\n            });\r\n        }\r\n\r\n        // find out end position\r\n        let iRow = matRow, iCol = matCol, iNumber,\r\n            maxRowBefore = this.matrix.length - 1,\r\n            maxColBefore = this.matrix[0].length - 1;\r\n        // search by row\r\n        while(iRow <= maxRowBefore - 1){\r\n            iNumber = this.matrix[iRow+1][iCol];\r\n            if (number != iNumber){\r\n                break;\r\n            }\r\n            iRow++;\r\n        }\r\n        // search by col\r\n        while(iCol <= maxColBefore - 1){\r\n            iNumber = this.matrix[iRow][iCol+1];\r\n            if (number != iNumber){\r\n                break;\r\n            }\r\n            iCol++;\r\n        }\r\n        endPos = [iRow, iCol];\r\n\r\n        return [startPos, endPos];\r\n    },\r\n\r\n\r\n    /**\r\n     * get all matrix unit of which was by TD holding\r\n     * @param  {...any} arrTd \r\n     */\r\n    getMatRectangeAreaByTd(...arrTd){\r\n        let me = this,\r\n            arrMat = [];\r\n        arrTd.forEach(\r\n            (td)=>{\r\n                if (!td) return;\r\n                if (me.cellType(td) == me.CELL_NORMAL){\r\n                    arrMat.push(me.matrixTd2Mat(...me.getTdIndex(td)));\r\n                }else{\r\n                    arrMat.push(...me.getBigCellSize(...me.matrixTd2Mat(...me.getTdIndex(td))));\r\n                }\r\n            }\r\n        );\r\n        return this.getMatRectangeArea(...arrMat);\r\n    },\r\n\r\n\r\n    /**\r\n     * give some matrix axis, return all matrix unit of which was by TD there.\r\n     * @param  {...any} mats \r\n     */\r\n    getMatRectangeArea(...mats){\r\n        let area = [\r\n                [mats[0][0], mats[0][1]],\r\n                [mats[0][0], mats[0][1]]\r\n            ],\r\n            mat,\r\n            areaJoin;\r\n        mats.shift();\r\n\r\n        while(mats.length > 0){\r\n            mat = mats.pop();\r\n            if (this.cellType(...mat) == this.CELL_NORMAL){\r\n                areaJoin = [mat,mat];\r\n            }else{\r\n                areaJoin = this.getBigCellSize(...mat);\r\n            }\r\n\r\n            // expand area with the other.\r\n            area = [\r\n                    [Math.min(area[0][0], areaJoin[0][0]), Math.min(area[0][1], areaJoin[0][1])],\r\n                    [Math.max(area[1][0], areaJoin[1][0]), Math.max(area[1][1], areaJoin[1][1])]\r\n                ];\r\n        }\r\n\r\n        return area;\r\n    },\r\n};","// tidy girl\r\n// append column or row\r\nexport default {\r\n    addRow(){\r\n        this.forEachRow((row, rowIndex)=>{\r\n             let td = document.createElement('td');\r\n             row.append(td);\r\n        });\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    // can recognize each big cell, and expand them by increase their colspan.\r\n    insertRow(beforeTd){\r\n        // const beforeTr = beforeTd.parentNode;\r\n        const [tdRowIndex, tdColIndex] = this.getTdIndex(beforeTd);\r\n        let [sizeRow, sizeCell] = this.getSize();\r\n        const fnAddTd = () => trHolder.append(document.createElement('td'));\r\n        // first row.\r\n        const trHolder = document.createElement('tr');\r\n        if (tdRowIndex == 0) {\r\n            while (sizeCell > 0) {\r\n                fnAddTd();\r\n                sizeCell--;\r\n            }\r\n        } else {\r\n            // const tdBase = [];          // create row upon which TD.\r\n            const trHolder = document.createElement('tr');\r\n            let sizeIndex = 0;\r\n\r\n            while (sizeIndex < sizeCell) {\r\n                const tdFound = this.getTdByMatrix(tdRowIndex, sizeIndex);\r\n                const cellType = this.cellType(tdRowIndex, sizeIndex);\r\n                if (cellType == this.CELL_NORMAL) {\r\n                    fnAddTd();\r\n                    sizeIndex++;\r\n                } else if (cellType == this.CELL_BIG_HEAD) {\r\n                    let size = tdFound.colSpan;\r\n                    while (size > 0) {\r\n                        fnAddTd();\r\n                        size--;\r\n                    }\r\n                    sizeIndex += tdFound.colSpan;\r\n                } else if (cellType == this.CELL_BIG_HEAD || cellType == this.CELL_BIG) {\r\n                    tdFound.rowSpan += 1;\r\n                    sizeIndex += tdFound.colSpan;\r\n                }\r\n            }\r\n        }\r\n        beforeTd.parentNode.before(trHolder);\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    addCell(){\r\n        let [rowCount, colCount] = this.getSize(),\r\n            newTr = this.dom.insertRow(rowCount);\r\n        while(colCount>0){\r\n            newTr.append(document.createElement('td'));\r\n            colCount--;\r\n        }\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    insertCell(beforeThisTd){\r\n        // el matrix axis\r\n        // let [rowIndex, colIndex] = this.getTdIndex(beforeTd),\r\n        //     [rowCount, colCount] = this.getSize(),\r\n        //     newTr = this.dom.insertRow(rowIndex);\r\n        // while(colCount>0){\r\n        //     newTr.append(document.createElement('td'));\r\n        //     colCount--;\r\n        // }\r\n        // if beforeTd is the first of the row.\r\n        \r\n        let [tdRowIndex, tdColIndex] = this.getTdIndex(beforeThisTd);\r\n        if (tdColIndex == 0) {\r\n            this.forEachRow(row => {\r\n                row.childNodes[0].before(document.createElement('td'));\r\n            });\r\n        } else {\r\n            const tdDone = [];\r\n            const matrix = this.getTdMatrix(beforeThisTd);\r\n            this.forEachRow((row, indexRow) => {\r\n                const td = this.getTdByMatrix(indexRow, matrix[1] - 1);\r\n                if (tdDone.indexOf(td) == -1) {\r\n                    if (this.cellType(td) == this.CELL_NORMAL) {\r\n                        td.after(document.createElement('td'));\r\n                    } else {    // big cell\r\n                        td.colSpan += 1;\r\n                    }\r\n                    tdDone.push(td);\r\n                }\r\n            });\r\n        }\r\n        this.refresh();\r\n        return this;\r\n    }\r\n};"," // utils, a dog always hardworing.\r\nexport default{\r\n    tableClassName: '_table-butcher_',\r\n    init(table){\r\n        this.dom = table;\r\n    },\r\n\r\n    getSpan(td){\r\n        return [td.rowSpan, td.colSpan];\r\n    },\r\n\r\n\r\n    getTdIndex(td){\r\n        if (!td) return;\r\n        const tr = td.parentNode;\r\n        let rowIndex = -1,\r\n            colIndex = -1;\r\n        this.forEachRow((row, index)=>{\r\n            if (row === tr){\r\n                rowIndex = index;\r\n                return true;\r\n            }\r\n        });\r\n\r\n        const tds = tr.querySelectorAll('td');\r\n        tds.forEach((val, index)=>{\r\n            if (val === td){\r\n                colIndex = index;\r\n            }\r\n        });\r\n\r\n        return [rowIndex, colIndex];\r\n    },\r\n\r\n    getTdByIndex(tdRow, tdCol){\r\n        if (tdRow == -1 || tdCol == -1){\r\n            return null;\r\n        }\r\n        let inRow = -1, retTd;\r\n        this.forEachRow((row, index)=>{\r\n            if (tdRow == index){\r\n                inRow = row;\r\n                return true;\r\n            }\r\n        });\r\n        if (inRow == -1){\r\n            return null;\r\n        }else{\r\n            retTd = inRow.querySelectorAll(':scope > td')[tdCol];\r\n            return retTd;\r\n        }\r\n    },\r\n\r\n    getTdMatrix(td) {\r\n        return this.matrixTd2Mat(...this.getTdIndex(td));\r\n    },\r\n\r\n    getTdByMatrix(matRow, matCol){\r\n        return this.getTdByIndex(...this.matrixMat2Td(matRow, matCol));\r\n    },\r\n\r\n    /**\r\n     * calculate table rectangle size\r\n     */\r\n    getSize(){\r\n        let sizeCol = 0, me = this, allTdSize=[];\r\n        // find max column size\r\n        this.forEachRow((row, rowIndex)=>{\r\n            let thisRowSize = 0;\r\n            row.querySelectorAll(':scope > td').forEach((td, colIndex)=>{\r\n                let span = me.getSpan(td);\r\n                thisRowSize += span[1];\r\n            });\r\n            allTdSize.push(thisRowSize);\r\n        });\r\n        sizeCol = Math.max(...allTdSize);\r\n        // this.forUnderTable( (td)=>{\r\n        //     let span = me.getSpan(td);\r\n        //     sizeCol += span[1];\r\n        // }, '> tr:first-child > td');\r\n        return [\r\n            this.dom.querySelectorAll(`:scope > tbody > tr`).length,\r\n            sizeCol\r\n        ];\r\n    },\r\n\r\n    /**\r\n     * sort row by row\r\n     * @param {Array[TD]} tds \r\n     */\r\n    sort(arrTd){\r\n        let me = this;\r\n        arrTd.sort((a,b)=>{\r\n            let aPos = me.getTdIndex(a), // Do not mind.\r\n                bPos = me.getTdIndex(b); // Do not mind.\r\n            if (aPos[0] != bPos[0]){\r\n                return aPos[0] - bPos[0];\r\n            }else{\r\n                return aPos[1] - bPos[1];\r\n            }\r\n        })\r\n        return arrTd;\r\n    },\r\n\r\n    /**\r\n     * loop each td with tr and position detail\r\n     */\r\n    forEachCell(fn){\r\n        const fnTR = (tr, rowIndex)=>{\r\n            let tds = tr.querySelectorAll(':scope > td'),\r\n                colIndex = 0;\r\n            for(let td of tds){\r\n                fn(td, rowIndex, colIndex, tr);\r\n                colIndex++;\r\n            }\r\n        };\r\n        // this.forUnderTable(fnTR, '> tr');\r\n        this.forEachRow(fnTR);\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param {fn}  receive arguments(element, index, all elements)\r\n     */\r\n    forEachRow(fn){\r\n        this.forUnderTable(fn, '> tr');\r\n    },\r\n\r\n\r\n    /**\r\n     * loop under the table\r\n     */\r\n    forUnderTable(fn, selector = '> tr > td'){\r\n        let elements = this.dom.querySelectorAll(`:scope > tbody ` + selector);\r\n        let index = -1;\r\n        for(let el of elements){\r\n            index++;\r\n            if (true === fn(el, index, elements)){\r\n                return;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * loop with table matrix\r\n     * @param {function}    fn      invoke with argument (express number, row index, column index, row array)\r\n     */\r\n    forEachMatrix(fn){\r\n        let indexOfRow = -1,\r\n            indexOfCol = -1;\r\n        for(let row of this.matrix){\r\n            indexOfRow++;\r\n            indexOfCol = -1;\r\n            for(let col of row){\r\n                indexOfCol++;\r\n                if(true === fn(col, indexOfRow, indexOfCol, row)){\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * find the first same expression number in table matrix\r\n     * @param {integer} expNumber\r\n     */\r\n    findFirstTime(expNumber){\r\n        let ret = null;\r\n        this.forEachMatrix((val, row, col, arr)=>{\r\n            if (val === expNumber){\r\n                ret = [row, col];\r\n                return true;\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n};","import father from './father';\r\nimport mother from './mother';\r\nimport liLei from './liLei';\r\nimport hanMeiMei from './hanMeiMei';\r\nimport puppy from './puppy';\r\n\r\n// output layer\r\nlet diapason = {\r\n    dom: null,\r\n    ...father,\r\n    ...mother,\r\n    ...liLei,\r\n    ...hanMeiMei,\r\n    ...puppy\r\n};\r\n\r\n// entry class\r\nconst TableBuster = function(table){ \r\n    this.init(table);\r\n    this.buildMatrix();\r\n};\r\n// Object.assign(diapason, father, mother, liLei, hanMeiMei, puppy);\r\nTableBuster.prototype = diapason;\r\nwindow.TableBuster = TableBuster;\r\n// export default TableBuster;"]}