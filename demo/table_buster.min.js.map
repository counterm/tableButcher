{"version":3,"sources":["father.js","mother.js","liLei.js","hanMeiMei.js","puppy.js","nannyDom.js","home.js"],"names":["split","td","decorater","getSpan","spanRow","spanCol","nanny","setTdSpan","spanIndexCol","row","getRowByTd","dom","insertAfterTd","newTd","spanIndexRow","arrTdIndex","getTdIndex","arrTdMatrix","getTdMatrix","tr","getRowByIndex","tds","getTdsInRow","firstTdMatrix","length","Number","MAX_VALUE","appendTd","index","tdFound","tdFoundMatrix","insertBeforeTd","refresh","deleteColumn","tdColCount","tdColMatrix","tdColSpan","getTdColSpan","deleteColumnHandler","rowIndex","tdDone","tbSize","getSize","getTdByMatrix","indexOf","span","delTd","push","rowSpan","getTdRowSpan","deleteRow","tdRowCount","tdRowMatrix","tdRowSpan","deleteRowHandler","colIndex","nextTr","tdMarkShort","cellType","CELL_BIG_HEAD","nextTdColMatrix","nextRowTd","CELL_BIG","forEach","delTr","merge","tdFrom","tdTo","selectionTd","selectionByTd","arrTdInArea","area","matFrom","matTo","colSpan","firstTd","shift","moveTdChilds","mergeTo","direction","tdMatrix","nextMatrix","nextTd","matrixMat2Td","findAreaTd","selection","queue","tdFromPosition","getMatRectangeAreaByTd","tdFromAndEndPosition","me","matrixForInArea","num","newFound","newArea","concat","tdArea","cellCanCount","findFirstNumberPosition","sort","_refreshTimeout","CELL_NORMAL","matrix","buildMatrix","sizeRow","sizeCol","tmpRow","maxFillNumber","arr","Array","from","repeat","map","v","forEachCell","matrixTd2Mat","matRow","matCol","fillBigInMat","matrixFor","fn","col","ret","rowLoop","Math","min","max","colLoop","iRow","iCol","tdRow","tdCol","matRowArr","tdColIndex","retMatCol","expNumber","matColIndex","console","error","loopColIndex","startMatRow","startMatCol","cellSpan","indexRow","m","indexCol","endRow","endCol","matRowOrTd","number","arguments","tmpNum","targetNum","getBigCellSize","startNumber","startPos","numberSearch","maxRowBefore","maxColBefore","arrTd","arrMat","getMatRectangeArea","mats","mat","areaJoin","pop","addCellToAllRow","sizeCell","forEachRow","insertRow","beforeTd","tdRowIndex","trHolder","newTr","fnAddTd","cellIndex","sizeIndex","size","tdInRow","insertRowBefore","addNewRow","colCount","rowCount","insertEmptyRow","insertCell","beforeThisTd","colMatrix","operatorTd","insertBeforeThisTd","firstMatrix","tdAfter","getTdInRow","newInsertTd","tableClassName","init","table","initObj","obj","val","getTdByIndex","inRow","tdIndex","allTdSize","thisRowSize","getRowSize","a","b","aPos","bPos","eachRow","forEachMatrix","indexOfRow","indexOfCol","findFirstTime","isTheFirstTd","isTheLastTd","isTheFirstTr","isTheLastTr","findTheTdNext","findTheTdPrev","findTheTdAbove","findTheTdUnder","document","createElement","removeChild","childNodes","prototype","call","newRow","before","newEl","after","el","appendChild","tdSource","tdTarget","node","append","offset","diapason","father","mother","liLei","hanMeiMei","puppy","TableBuster","nannyDom","TableObjectBuster","nannyObj","object","window"],"mappings":"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","file":"table_buster.min.js","sourceRoot":"..\\src","sourcesContent":["// strong man\r\n/*\r\n\r\n*/\r\nexport default {\r\n    split(td, decorater) {\r\n        if (!td) return;\r\n        if (!decorater) decorater = (td) => td;\r\n        let [spanRow, spanCol] = this.getSpan(td);\r\n        if (spanRow > 1 || spanCol > 1) {\r\n            this.nanny.setTdSpan(td, 1, 1);\r\n            // row 1\r\n            let spanIndexCol = spanCol - 1;\r\n            while (spanIndexCol > 0) {\r\n                const row = this.nanny.getRowByTd(this.dom, td);\r\n                this.nanny.insertAfterTd(\r\n                    row,\r\n                    td,\r\n                    decorater(this.nanny.newTd(), 0, spanIndexCol - 1, this.dom, row)\r\n                );\r\n                spanIndexCol--;\r\n            }\r\n            // other row\r\n            let spanIndexRow = spanRow - 1 - 1;\r\n            const arrTdIndex = this.getTdIndex(td);\r\n            const arrTdMatrix = this.getTdMatrix(td);\r\n            while (spanIndexRow >= 0) {\r\n                spanIndexCol = spanCol - 1;\r\n                const tr = this.nanny.getRowByIndex(this.dom, arrTdIndex[0] + (spanRow - 1 - spanIndexRow));\r\n                const tds = this.nanny.getTdsInRow(tr);\r\n                const firstTdMatrix = tds.length > 0 ? this.getTdMatrix(tds[0]) : Number.MAX_VALUE;\r\n                /*\r\n                    1. The td ready to merge was on the first cell index.\r\n                    2. The row was empty.\r\n                    3. The first td in the row must be after the td which ready to insert.\r\n                 */\r\n                if (arrTdMatrix[0] == 0 && tds.length == 0 && firstTdMatrix[1] <= arrTdMatrix[1]) {\r\n                    while (spanIndexCol >= 0) {\r\n                        this.nanny.appendTd(\r\n                            tr,\r\n                            decorater(\r\n                                this.nanny.newTd(),\r\n                                spanRow - 1 - spanIndexRow,\r\n                                spanCol - 1 - spanIndexCol,\r\n                                this.dom,\r\n                                tr\r\n                            )\r\n                        );\r\n                        spanIndexCol--;\r\n                    }\r\n                } else {\r\n                    for (let index = 0; index < tds.length; index++) {\r\n                        const tdFound = tds[index];\r\n                        const tdFoundMatrix = this.getTdMatrix(tdFound);\r\n                        if (tdFoundMatrix[1] > arrTdMatrix[1]) {\r\n                            while (spanIndexCol >= 0) {\r\n                                this.nanny.insertBeforeTd(\r\n                                    tr,\r\n                                    tdFound,\r\n                                    decorater(\r\n                                        this.nanny.newTd(),\r\n                                        spanRow - 1 - spanIndexRow,\r\n                                        spanCol - 1 - spanIndexCol,\r\n                                        this.dom,\r\n                                        tr\r\n                                    )\r\n                                );\r\n                                spanIndexCol--;\r\n                            }\r\n                            break;\r\n                        } else if (index + 1 == tds.length) {   // last position\r\n                            while (spanIndexCol >= 0) {\r\n                                this.nanny.insertAfterTd(\r\n                                    tr,\r\n                                    tdFound,\r\n                                    decorater(\r\n                                        this.nanny.newTd(),\r\n                                        spanRow - 1 - spanIndexRow,\r\n                                        spanIndexCol - 1,\r\n                                        this.dom,\r\n                                        tr\r\n                                    )\r\n                                );\r\n                                spanIndexCol--;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                spanIndexRow--;\r\n            }\r\n        }\r\n        this.refresh();\r\n    },\r\n\r\n    deleteColumn(td) {\r\n        if (!td) return;\r\n        // const size = td.colSpan;\r\n        const [tdRowMatrix, tdColMatrix] = this.getTdMatrix(td);\r\n        const tdColSpan = this.nanny.getTdColSpan(td);\r\n        let tdColCount = 0;\r\n\r\n        while (tdColCount < tdColSpan) {\r\n            this.deleteColumnHandler(tdColMatrix);\r\n            this.refresh();\r\n            tdColCount++;\r\n        }\r\n    },\r\n\r\n    deleteColumnHandler(tdColMatrix) {\r\n        const tdDone = [];\r\n        const tbSize = this.getSize();\r\n        let rowIndex = 0;\r\n\r\n        while (rowIndex < tbSize[0]) {\r\n            const tdFound = this.getTdByMatrix(rowIndex, tdColMatrix);\r\n            if (tdFound && tdDone.indexOf(tdFound) == -1) {\r\n                let span = this.nanny.getTdColSpan(tdFound);\r\n                if (span > 1) {\r\n                    this.nanny.setTdSpan(tdFound, null, span - 1);\r\n                } else {\r\n                    this.nanny.delTd(this.nanny.getRowByIndex(this.dom, rowIndex), tdFound);\r\n                }\r\n                tdDone.push(tdFound);\r\n                // fix some td rowSpan greater than 1, and delete wrong TDs in the next row.\r\n                const rowSpan = this.nanny.getTdRowSpan(tdFound);\r\n                if (rowSpan > 1) {\r\n                    rowIndex += rowSpan;\r\n                    continue;\r\n                }\r\n            }\r\n            rowIndex++;\r\n        }\r\n    },\r\n    \r\n    deleteRow(td) {\r\n        if (!td) return;\r\n        const [tdRowMatrix, tdColMatrix] = this.getTdMatrix(td);\r\n\r\n        const tdRowSpan = this.nanny.getTdRowSpan(td);\r\n        let tdRowCount = 0;\r\n        while (tdRowCount < tdRowSpan) {\r\n            this.deleteRowHandler(tdRowMatrix);\r\n            this.refresh();\r\n            tdRowCount++;\r\n        }\r\n    },\r\n\r\n    deleteRowHandler(tdRowMatrix) {\r\n        const tr = this.nanny.getRowByIndex(this.dom, tdRowMatrix);\r\n        // const nextTr = tr.nextElementSibling;\r\n        const nextTr = this.nanny.getRowByIndex(this.dom, tdRowMatrix + 1);\r\n        const tbSize = this.getSize();\r\n        let colIndex = 0;\r\n        const tdMarkShort = [];\r\n        while (colIndex < tbSize[1]) {\r\n            const cellType = this.cellType(tdRowMatrix, colIndex);\r\n\r\n            // \r\n            if (cellType == this.CELL_BIG_HEAD) {\r\n                const tdFound = this.getTdByMatrix(tdRowMatrix, colIndex);\r\n                const tdRowSpan = this.nanny.getTdRowSpan(tdFound);\r\n                const tdColSpan = this.nanny.getTdColSpan(tdFound);\r\n                // move tdFound to next tr\r\n                if (tdRowSpan > 1 && tbSize[0] != tdRowMatrix) {\r\n                    let nextTdColMatrix = colIndex + tdColSpan;\r\n                    while (nextTdColMatrix < tbSize[1]) {\r\n                        const nextRowTd = this.getTdByMatrix(tdRowMatrix + 1, nextTdColMatrix);\r\n                        const row = this.nanny.getRowByIndex(this.dom, tdRowMatrix + 1);\r\n                        if (row == nextTr) {\r\n                            // nextRowTd.before(tdFound);\r\n                            this.nanny.insertBeforeTd(row, nextRowTd, tdFound);\r\n                            break;\r\n                        }\r\n                        nextTdColMatrix++;\r\n                    }\r\n                    const tdFoundInRow = this.nanny.getRowByTd(tdFound);\r\n                    if (tdFoundInRow != nextTr && nextTr) {\r\n                        this.nanny.appendTd(nextTr, tdFound);\r\n                    }\r\n                    // make sure short it.\r\n                    this.nanny.setTdSpan(tdFound, -1, null, true);\r\n                    // tdFound.rowSpan--;\r\n                    this.refresh();\r\n                }\r\n\r\n                // colIndex += tdFound.colSpan;\r\n                colIndex += tdColSpan;\r\n            } else if(cellType == this.CELL_BIG) {\r\n                const tdFound = this.getTdByMatrix(tdRowMatrix, colIndex);\r\n                tdMarkShort.push(tdFound);\r\n                this.refresh();\r\n                const tdColSpan = this.nanny.getTdColSpan(tdFound);\r\n                // colIndex += tdFound.colSpan;\r\n                colIndex += tdColSpan;\r\n            } else {\r\n                colIndex++;\r\n            }\r\n        }\r\n        tdMarkShort.forEach((td) => this.nanny.setTdSpan(td, -1, null, true));\r\n        this.nanny.delTr(this.dom, tr);\r\n    }\r\n};","// merge, nice women\r\nexport default {\r\n    /**\r\n     * \r\n     * @param {Element} tdFrom \r\n     * @param {Element} tdTo \r\n     */\r\n    merge(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let selectionTd = this.selectionByTd(tdFrom, tdTo),\r\n            arrTdInArea = selectionTd.td,\r\n            [matFrom, matTo] = selectionTd.area,\r\n            rowSpan = matTo[0] - matFrom[0] + 1,\r\n            colSpan = matTo[1] - matFrom[1] + 1,\r\n            firstTd = arrTdInArea.shift();\r\n        \r\n        // remove node\r\n        arrTdInArea.forEach((td, index)=>{\r\n            this.nanny.moveTdChilds(td, firstTd);\r\n            const tr = this.nanny.getRowByTd(this.dom, td);\r\n            this.nanny.delTd(tr, td);\r\n        });\r\n\r\n        // merge node\r\n        this.nanny.setTdSpan(firstTd, rowSpan, colSpan);\r\n        // firstTd.rowSpan = rowSpan;\r\n        // firstTd.colSpan = colSpan;\r\n\r\n        this.refresh();\r\n    },\r\n\r\n    /**\r\n     * \r\n     * @param {*} td           relative td\r\n     * @param {*} direction    0 up, 1 right, 2 down, 3 left\r\n     * \r\n     */\r\n    mergeTo(td, direction) {\r\n        const tdMatrix = this.getTdMatrix(td);\r\n        const nextMatrix = [...tdMatrix];\r\n        switch (direction) {\r\n            case 0:\r\n                nextMatrix[0]--;\r\n                break;\r\n            case 1:\r\n                const colSpan = this.nanny.getTdColSpan(td);\r\n                nextMatrix[1] += colSpan;\r\n                break;\r\n            case 2:\r\n                const rowSpan = this.nanny.getTdRowSpan(td);\r\n                nextMatrix[0] += rowSpan;\r\n                break;\r\n            default:\r\n                nextMatrix[1]--;\r\n                break;\r\n        }\r\n        const nextTd = this.getTdByMatrix(...nextMatrix);\r\n        if (nextTd) {\r\n            this.merge(td, nextTd);\r\n            return this.matrixMat2Td(...tdMatrix);\r\n        } else {\r\n            return null;\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {Element} tdFrom \r\n     * @param {Element} tdTo \r\n     */\r\n    findAreaTd(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let selection = this.selectionByTd(tdFrom, tdTo);\r\n        return selection.td;\r\n    },\r\n\r\n\r\n\r\n\r\n    /**\r\n     * All TDs in rectange selection.\r\n     * @param {Element} tdFrom\r\n     * @param {Element} tdTo\r\n     */\r\n    selectionByTd(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let queue = [tdFrom, tdTo],\r\n            index = 0,\r\n            tdFromPosition = this.getMatRectangeAreaByTd(tdFrom),\r\n            tdFromAndEndPosition = this.getMatRectangeAreaByTd(tdFrom, tdTo),\r\n            area = [\r\n                tdFromPosition[0][0], tdFromPosition[0][1],  // left top\r\n                tdFromPosition[1][0], tdFromPosition[1][1]   // right bottom\r\n            ],\r\n            me = this;\r\n\r\n\r\n        // find other TD inner area\r\n        // TODO: can be optimized.\r\n        this.matrixForInArea(\r\n            tdFromAndEndPosition[0], tdFromAndEndPosition[1], \r\n            (num, rowIndex, colIndex)=>{\r\n                let td = me.getTdByMatrix(rowIndex, colIndex);\r\n                if (queue.indexOf(td) == -1){\r\n                    queue.push(td);\r\n                }\r\n            }\r\n        );\r\n\r\n        // find big cell expand\r\n        while(index < queue.length){\r\n            let newFound = false,\r\n                newArea = area.concat(),\r\n                tdArea = this.getMatRectangeAreaByTd(queue[index]);\r\n\r\n            if (tdArea[0][0] < newArea[0]){\r\n                newArea[0] = tdArea[0][0];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[0][1] < newArea[1]){\r\n                newArea[1] = tdArea[0][1];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[1][0] > newArea[2]){\r\n                newArea[2] = tdArea[1][0];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[1][1] > newArea[3]){\r\n                newArea[3] = tdArea[1][1];\r\n                newFound = true;\r\n            }\r\n\r\n            if (newFound == true){\r\n                let me = this;\r\n                this.matrixForInArea(\r\n                    [newArea[0], newArea[1]],\r\n                    [newArea[2], newArea[3]],\r\n                    (num, rowIndex, colIndex)=>{\r\n                        if (rowIndex < area[0] || rowIndex > area[2] || colIndex < area[1] || colIndex > area[3]){ // out of the past area \r\n                            // find head unit of big cell\r\n                            if (me.cellCanCount(rowIndex, colIndex) == false){\r\n                                [rowIndex, colIndex] = me.findFirstNumberPosition(rowIndex, colIndex);\r\n                                if (rowIndex == -1 || colIndex == -1)\r\n                                    return;    \r\n                            }\r\n                            let td = me.getTdByMatrix(rowIndex, colIndex);\r\n                            if (queue.indexOf(td) == -1){\r\n                                queue.push(td);\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n                area = newArea;\r\n            }\r\n            index++;\r\n        }\r\n        queue = this.sort(queue);\r\n        return {td:queue, area: [[area[0], area[1]], [area[2], area[3]]]};\r\n    },\r\n\r\n};","// A creative boy\r\n// something about table matrix\r\nlet _refreshTimeout = 0;\r\nexport default {\r\n    /*\r\n\r\n    table expression\r\n    0 0 0\r\n    0 0 0\r\n    0 0 0\r\n\r\n    every number point to a td position.\r\n    0 is a normal td, other number is a large td's placehodler.\r\n    As a big cell, it place all the same number to mark the position, \r\n    except the first place. for example '3', first number will be '-3'.\r\n\r\n    example:\r\n    0 -1 1 0\r\n    0 1 1 0\r\n\r\n    <table>\r\n        <tr>\r\n            <td></td>\r\n            <td colspan=\"2\" rowspan=\"2\"></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n    </table>\r\n\r\n    */\r\n    CELL_NORMAL       : 0,\r\n    CELL_BIG          : 1,\r\n    CELL_BIG_HEAD     : 2,\r\n    matrix:[[]],\r\n    refresh(){\r\n        // let time = +new Date();\r\n        // window.clearTimeout(_refreshTimeout);\r\n        // _refreshTimeout = window.setTimeout(() => this.buildMatrix(), 300);\r\n        this.buildMatrix();\r\n        // console.log(`refresh time use: ${(+new Date() - time)}ms`);\r\n    },\r\n\r\n\r\n    buildMatrix(){\r\n        let [sizeRow, sizeCol] = this.getSize(),\r\n            tmpRow = sizeRow,\r\n            maxFillNumber = 1; \r\n        // fill zero at all\r\n        this.matrix = [];\r\n        while(tmpRow > 0){\r\n            const arr = Array.from('0'.repeat(sizeCol)).map(v => +v);\r\n            this.matrix.push(arr);\r\n            tmpRow--;\r\n        }\r\n        // recognize big cell\r\n        this.forEachCell((td, rowIndex, colIndex, tr) => {\r\n            let [rowSpan, colSpan] = this.getSpan(td);\r\n            let [matRow, matCol] = this.matrixTd2Mat(rowIndex, colIndex);\r\n            // checkout big cell and fill number\r\n            if (rowSpan > 1 || colSpan > 1){\r\n                // count actual column index\r\n                this.fillBigInMat(maxFillNumber, matRow, matCol, rowSpan, colSpan);\r\n                maxFillNumber++;\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * \r\n     * @param {Function} fn (number, rowIndex, colIndex)\r\n     */\r\n    matrixFor(fn){\r\n        let rowIndex = 0, colIndex = 0, ret;\r\n        for(let row of this.matrix){\r\n            colIndex = 0;\r\n            for(let col of row){\r\n                ret = fn(col, rowIndex, colIndex);\r\n                if(ret == true)\r\n                    return col;\r\n                colIndex++;\r\n            }\r\n            rowIndex++;\r\n        }\r\n    },\r\n\r\n\r\n    matrixForInArea(matFrom , matTo, fn){\r\n        let rowLoop = [Math.min(matFrom[0], matTo[0]), Math.max(matFrom[0], matTo[0])],\r\n            colLoop = [Math.min(matFrom[1], matTo[1]), Math.max(matFrom[1], matTo[1])];\r\n        \r\n        for(let iRow = rowLoop[0]; iRow <= rowLoop[1]; iRow++){\r\n            for(let iCol = colLoop[0]; iCol <= colLoop[1]; iCol++){\r\n                if (fn(this.matrix[iRow][iCol], iRow, iCol) === true){\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n\r\n    // change axis\r\n    matrixTd2Mat(tdRow, tdCol){\r\n        let matRow = tdRow,\r\n            matRowArr = this.matrix[tdRow],\r\n            tdColIndex = -1,\r\n            retMatCol = -1,\r\n            me = this;\r\n        matRowArr.forEach((expNumber, matColIndex)=>{\r\n            if (me.cellCanCount(matRow, matColIndex)){\r\n                tdColIndex++;\r\n            }\r\n            if (retMatCol == -1 && tdColIndex === tdCol){\r\n                retMatCol = matColIndex;\r\n            }\r\n        });\r\n        return [matRow, retMatCol];\r\n    },\r\n\r\n\r\n    // change axis\r\n    matrixMat2Td(matRow, matCol) {\r\n        if (this.matrix.length > 0 &&\r\n            (\r\n                matRow < 0 || matCol < 0 ||\r\n                matRow >= this.matrix.length || matCol >= this.matrix[0].length\r\n            )\r\n        ) {\r\n            console.error('Out of range in Method MatrixMat2Td')\r\n            return null\r\n        }\r\n        if (this.cellType(matRow, matCol) === this.CELL_BIG){\r\n            [matRow, matCol] = this.findFirstNumberPosition(matRow, matCol);\r\n        }\r\n        let loopColIndex = 0, \r\n            tdRow = matRow,\r\n            tdCol = -1;\r\n        while(loopColIndex <= matCol){\r\n            if (this.cellCanCount(matRow, loopColIndex)){\r\n                tdCol++;\r\n            } \r\n            loopColIndex++;\r\n        }\r\n        return [tdRow, tdCol];\r\n        // matrix number\r\n        // let number = this.matrix[matRow][matCol],\r\n        //     count = -1;\r\n        // if (this.cellCanCount(matRow, matCol)){\r\n        //     count++;\r\n        // }else{\r\n\r\n        // }\r\n        // try{\r\n        //     number = ;\r\n        // }catch(e){\r\n        //     console.log(`matrixMat2Td fail. ${matRow}, ${matCol} overload.`);\r\n        //     console.log(e);\r\n        //     return null;\r\n        // }\r\n\r\n    },\r\n\r\n\r\n\r\n    // in big cell area, fill number in it, except first number was multiply -1\r\n    fillBigInMat(expNumber, startMatRow, startMatCol, rowSpan, cellSpan){\r\n        let m = this.matrix;\r\n        let endRow = startMatRow + rowSpan - 1,\r\n            endCol = startMatCol + cellSpan - 1,\r\n            indexRow = startMatRow, \r\n            indexCol;\r\n        while(indexRow <= endRow){\r\n            indexCol = startMatCol;\r\n            while(indexCol <= endCol){\r\n                m[indexRow][indexCol] = expNumber;\r\n                indexCol++;\r\n            }\r\n            indexRow++;\r\n        }\r\n        // rewrite first number\r\n        m[startMatRow][startMatCol] = -1 * expNumber;\r\n    },\r\n\r\n\r\n    // return [0,1,2]\r\n    //   0: not a big cell\r\n    //   1: is a big cell, not the first place\r\n    //   2: is a big cell and is the first place\r\n    cellType(matRowOrTd, matCol){\r\n        let number = null, ret;\r\n        \r\n        if (matCol == null){\r\n            // argument was td\r\n            if (typeof matRowOrTd == 'number') {\r\n                number = matRowOrTd;\r\n            } else {\r\n                [matRowOrTd, matCol] = this.matrixTd2Mat(...this.getTdIndex(matRowOrTd));\r\n            }\r\n        }\r\n        \r\n        if (number == null && matCol != null){\r\n            number = this.matrix[matRowOrTd][matCol];\r\n        }\r\n\r\n        number = +number;\r\n        if (number == 0){\r\n            ret = this.CELL_NORMAL;\r\n        }else if(number > 0){\r\n            ret = this.CELL_BIG;\r\n        }else{\r\n            ret = this.CELL_BIG_HEAD;\r\n        }\r\n        \r\n        return ret;\r\n    },\r\n\r\n\r\n    // judge the cell single or belong to big cell for that can not be count.\r\n    cellCanCount(matRow, matCol){\r\n        let type = this.cellType(...arguments);\r\n        // If matrix unit number is not bigger than 0, it will specify to a true td.\r\n        if (this.CELL_BIG != this.cellType(matRow, matCol)){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * td in matrix return matrix number of the head\r\n     * @param {Array(x,y)} matRow \r\n     * @param {Array(x,y)} matCol \r\n     */\r\n    findFirstNumberPosition(matRow, matCol){\r\n        let m = this.matrix,\r\n            number = this.matrix[matRow][matCol];\r\n\r\n        if (this.CELL_BIG == this.cellType(matRow, matCol)){\r\n            let rowIndex = matRow,\r\n                colIndex = matCol,\r\n                tmpNum = m[rowIndex][colIndex],\r\n                targetNum = -1 * number;\r\n\r\n            // move left in row\r\n            while(colIndex >= 0){\r\n                tmpNum = m[rowIndex][colIndex];\r\n                if (tmpNum == targetNum){\r\n                    return [rowIndex, colIndex];\r\n                }else if(tmpNum == number){\r\n                    colIndex--;\r\n                }else{\r\n                    // our of range, move up.\r\n                    colIndex++;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            colIndex = colIndex < 0 ? 0 : colIndex;\r\n            rowIndex--;\r\n            \r\n            // move up in col\r\n            while(rowIndex >= 0){\r\n                tmpNum = m[rowIndex][colIndex];\r\n                if (tmpNum == targetNum){\r\n                    return [rowIndex, colIndex];\r\n                }else if(tmpNum == number){\r\n                    rowIndex--;\r\n                }else{\r\n                    // out of range\r\n                    break;\r\n                }\r\n            }\r\n            // can not found, return [-1, -1].\r\n            return [-1, -1]\r\n        }else{\r\n            return [matRow, matCol];\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * find cell in matrix axis, and recognize all cell area in matrix axis, \r\n     * return the start and end.\r\n     * @param {Array(x,y)} matRow \r\n     * @param {Array(x,y)} matCol \r\n     * @return [[indexX, indexY], [indexX, indexY]]\r\n     */\r\n    getBigCellSize(matRow, matCol){\r\n        let number = this.matrix[matRow][matCol],\r\n            startNumber;\r\n        let startPos = [], endPos = [];\r\n        if (this.cellType(number) == this.CELL_NORMAL){\r\n            return [[matRow, matCol], [matRow, matCol]];\r\n        }else if (this.cellType(number) == this.CELL_BIG_HEAD){\r\n            startNumber = number;\r\n            number = -1 * number;\r\n            startPos = [matRow, matCol];\r\n        }else{\r\n            startNumber = -1 * number;\r\n\r\n            // findout start position\r\n            this.matrixFor((numberSearch, rowIndex, colIndex)=>{\r\n                if (numberSearch == startNumber){\r\n                    startPos = [rowIndex, colIndex];\r\n                }\r\n            });\r\n        }\r\n\r\n        // find out end position\r\n        let iRow = matRow, iCol = matCol, iNumber,\r\n            maxRowBefore = this.matrix.length - 1,\r\n            maxColBefore = this.matrix[0].length - 1;\r\n        // search by row\r\n        while(iRow <= maxRowBefore - 1){\r\n            iNumber = this.matrix[iRow+1][iCol];\r\n            if (number != iNumber){\r\n                break;\r\n            }\r\n            iRow++;\r\n        }\r\n        // search by col\r\n        while(iCol <= maxColBefore - 1){\r\n            iNumber = this.matrix[iRow][iCol+1];\r\n            if (number != iNumber){\r\n                break;\r\n            }\r\n            iCol++;\r\n        }\r\n        endPos = [iRow, iCol];\r\n\r\n        return [startPos, endPos];\r\n    },\r\n\r\n\r\n    /**\r\n     * get all matrix unit of which was by TD holding\r\n     * @param  {...any} arrTd \r\n     * @return [[startMatrixX, startMatrixY], [endMatrixX, endMatrixY]]\r\n     */\r\n    getMatRectangeAreaByTd(...arrTd){\r\n        let me = this,\r\n            arrMat = [];\r\n        arrTd.forEach(\r\n            (td)=>{\r\n                if (!td) return;\r\n                if (me.cellType(td) == me.CELL_NORMAL){\r\n                    arrMat.push(me.matrixTd2Mat(...me.getTdIndex(td)));\r\n                }else{\r\n                    arrMat.push(...me.getBigCellSize(...me.matrixTd2Mat(...me.getTdIndex(td))));\r\n                }\r\n            }\r\n        );\r\n        return this.getMatRectangeArea(...arrMat);\r\n    },\r\n\r\n\r\n    /**\r\n     * give some matrix axis, return all matrix unit of which was by TD there.\r\n     * @param  {...any} mats \r\n     */\r\n    getMatRectangeArea(...mats){\r\n        let area = [\r\n                [mats[0][0], mats[0][1]],\r\n                [mats[0][0], mats[0][1]]\r\n            ],\r\n            mat,\r\n            areaJoin;\r\n        mats.shift();\r\n\r\n        while(mats.length > 0){\r\n            mat = mats.pop();\r\n            if (this.cellType(...mat) == this.CELL_NORMAL){\r\n                areaJoin = [mat,mat];\r\n            }else{\r\n                areaJoin = this.getBigCellSize(...mat);\r\n            }\r\n\r\n            // expand area with the other.\r\n            area = [\r\n                    [Math.min(area[0][0], areaJoin[0][0]), Math.min(area[0][1], areaJoin[0][1])],\r\n                    [Math.max(area[1][0], areaJoin[1][0]), Math.max(area[1][1], areaJoin[1][1])]\r\n                ];\r\n        }\r\n\r\n        return area;\r\n    },\r\n};","// tidy girl\r\n// append column or row\r\nexport default {\r\n    addCellToAllRow(fn){\r\n        let [sizeRow, sizeCell] = this.getSize();\r\n        this.forEachRow((row, rowIndex)=>{\r\n            let td = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(td, rowIndex, sizeCell, this.dom, row);\r\n                retFn && td == retFn;\r\n            }\r\n            this.nanny.appendTd(row, td);\r\n        });\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    // Method can recognize each big cell, and expand them by increase their colspan.\r\n    insertRow(beforeTd, fn){\r\n        const [tdRowIndex, tdColIndex] = this.getTdIndex(beforeTd);\r\n        let [sizeRow, sizeCell] = this.getSize();\r\n        const trHolder = this.nanny.newTr();\r\n\r\n        const fnAddTd = (cellIndex) => {\r\n            let td = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(td, tdRowIndex, cellIndex, this.dom, trHolder);\r\n                retFn && td == retFn;\r\n            }\r\n            this.nanny.appendTd(trHolder, td);\r\n        };\r\n\r\n        // first row.\r\n        if (tdRowIndex == 0) {\r\n            let cellIndex = 0;\r\n            while (cellIndex < sizeCell) {\r\n                fnAddTd(cellIndex);\r\n                cellIndex++;\r\n            }\r\n        } else {\r\n            // const tdBase = [];          // create row upon which TD.\r\n            let sizeIndex = 0;\r\n\r\n            while (sizeIndex < sizeCell) {\r\n                const tdFound = this.getTdByMatrix(tdRowIndex, sizeIndex);\r\n                const cellType = this.cellType(tdRowIndex, sizeIndex);\r\n                const colSpan = this.nanny.getTdColSpan(tdFound);\r\n                if (cellType == this.CELL_NORMAL) {\r\n                    fnAddTd(sizeIndex);\r\n                    sizeIndex++;\r\n                } else if (cellType == this.CELL_BIG_HEAD) {\r\n                    let size = colSpan;\r\n                    while (size > 0) {\r\n                        fnAddTd(sizeIndex);\r\n                        size--;\r\n                    }\r\n                    sizeIndex += colSpan;\r\n                } else if (cellType == this.CELL_BIG_HEAD || cellType == this.CELL_BIG) {\r\n                    this.nanny.setTdSpan(tdFound, 1, null, true);\r\n                    sizeIndex += colSpan;\r\n                }\r\n            }\r\n        }\r\n        const tdInRow = this.nanny.getRowByTd(this.dom, beforeTd);\r\n        this.nanny.insertRowBefore(this.dom, tdInRow, trHolder);\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    addNewRow(fn){\r\n        let [rowCount, colCount] = this.getSize();\r\n        const newTr = this.nanny.insertEmptyRow(this.dom, rowCount);\r\n        let index = 0;\r\n        while(colCount>0){\r\n            let newTd = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(newTd, rowCount, index, this.dom, newTr);\r\n                retFn && newTd == retFn;\r\n            }\r\n            this.nanny.appendTd(newTr, newTd);\r\n            colCount--;\r\n            index++;\r\n        }\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    insertCell(beforeThisTd, fn){\r\n        let [tdRowIndex, tdColIndex] = this.getTdMatrix(beforeThisTd);\r\n\r\n        let newInsertTd = (rowIndex, cellIndex, row) => {\r\n            let newTd = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(newTd, rowIndex, cellIndex, this.dom, row);\r\n                retFn && newTd == retFn;\r\n            }\r\n            return newTd;\r\n        };\r\n\r\n        // if selected td was the first column\r\n        if (tdColIndex == 0) {\r\n            this.forEachRow((row, rowIndex) => {\r\n                this.nanny.insertBeforeTd(row, this.nanny.getTdInRow(row, 0), newInsertTd(rowIndex, tdColIndex, row));\r\n            });\r\n            return;\r\n        }\r\n\r\n        // \r\n        const matrix = this.getTdMatrix(beforeThisTd);\r\n        const colMatrix = matrix[1];\r\n        const size = this.getSize();\r\n\r\n        let index = -1;\r\n        /*\r\n         0 0 x 0 0 0 0\r\n         0 0 x 0 0 0 0\r\n         0 0 x 0 0 0 0\r\n         0 0 x 0 0 0 0\r\n         Scan one column, will meet normal td size, or big td.\r\n         Big td has 4 placements.\r\n         For example, it is now scanning to position (1, 2)\r\n\r\n         1.In big td's head.\r\n         0 0 0 0 0 0 0\r\n         0 0 -1 1 1 0 0\r\n         0 0 1 1 1 0 0\r\n\r\n         2.In big td's left side.\r\n         0 0 -1 1 1 0 0\r\n         0 0 1 1 1 0 0\r\n         0 0 0 0 0 0 0\r\n\r\n         3.In big td's upper middle position.\r\n         0 0 0 0 0 0 0\r\n         0 -1 1 1 0 0 0\r\n         0 1 1 1 0 0 0\r\n         0 0 0 0 0 0 0\r\n\r\n         4.In big td's middle or lower middle position.\r\n         0 -1 1 1 0 0 0\r\n         0 1 1 1 0 0 0\r\n         0 0 0 0 0 0 0\r\n         0 0 0 0 0 0 0\r\n         */\r\n        const operatorTd = [\r\n            [], // insertBefore\r\n            []  // increase colspan\r\n        ]\r\n        while (index < size[0] - 1) {\r\n            index++;\r\n\r\n            const insertBeforeThisTd = this.getTdByMatrix(index, colMatrix);\r\n            const tdIsBig = this.cellType(insertBeforeThisTd) != this.CELL_NORMAL;\r\n\r\n            if (!tdIsBig) {\r\n                // this.nanny.insertBeforeTd(tr, insertBeforeThisTd, this.nanny.newTd());\r\n                operatorTd[0].push(insertBeforeThisTd);\r\n            } else {\r\n                const firstMatrix = this.findFirstNumberPosition(index, colMatrix);\r\n                // 1\r\n                if (firstMatrix[0] == index && firstMatrix[1] == colMatrix) {\r\n                    operatorTd[0].push(insertBeforeThisTd);\r\n                } else if (firstMatrix[0] != index && firstMatrix[1] == colMatrix) {\r\n                    // 2\r\n                    const colSpan = this.nanny.getTdColSpan(insertBeforeThisTd);\r\n                    const tdAfter = this.getTdByMatrix(index, colMatrix + colSpan);\r\n                    operatorTd[0].push(tdAfter);\r\n                } else if (firstMatrix[0] == index && firstMatrix[1] < colMatrix) {\r\n                    // 3\r\n                    operatorTd[1].push(insertBeforeThisTd);\r\n                } else if (firstMatrix[0] < index && firstMatrix[1] < colMatrix) {\r\n                    // 4\r\n                    continue;\r\n                } else {\r\n                    console.error('Cases not treated.');\r\n                }\r\n            }\r\n        }\r\n\r\n        operatorTd[0].forEach(td => {\r\n            const tr = this.nanny.getRowByTd(this.dom, td);\r\n            this.nanny.insertBeforeTd(tr, td, this.nanny.newTd());\r\n        });\r\n\r\n        operatorTd[1].forEach(td => {\r\n            this.nanny.setTdSpan(td, null, 1, true);\r\n        })\r\n\r\n        // const bigTdCount = [];\r\n        // const prevTdMatrixColumnTail = matrix[1] - 1;\r\n        /*\r\n        this.forEachRow((row, indexRow) => {\r\n            \r\n            const td = this.getTdByMatrix(indexRow, prevTdMatrixColumnTail);\r\n            if (bigTdCount.indexOf(td) == -1) {\r\n                if (this.cellType(td) == this.CELL_NORMAL) {\r\n                    this.nanny.insertAfterTd(row, td, newInsertTd(indexRow, tdColIndex, row));\r\n                } else {\r\n                    this.nanny.setTdSpan(td, null, 1, true);\r\n                }\r\n                bigTdCount.push(td);\r\n            } else {\r\n                const colSpan = this.nanny.getTdColSpan(td);\r\n                if (prevTdMatrixColumnTail - colSpan >= 0) {\r\n                    const td2 = this.getTdByMatrix(indexRow, prevTdMatrixColumnTail - colSpan);\r\n                    this.nanny.insertAfterTd(row, td2, newInsertTd(indexRow, tdColIndex, row));\r\n                } else { // The big cell was full of the first column\r\n                    const td2 = this.getTdByMatrix(indexRow, 0);\r\n                    this.nanny.insertBeforeTd(row, td2, newInsertTd(indexRow, tdColIndex, row));\r\n                }\r\n            }\r\n        });\r\n        */\r\n        \r\n        /*\r\n        const matrix = this.getTdMatrix(beforeThisTd);\r\n        const tdPosSize = this.getBigCellSize(matrix[0], matrix[1] - 1);\r\n        const tbSize = this.getSize();\r\n\r\n        // If left side is just a totally td.\r\n        // Insert one cell to each row.\r\n        if (tdPosSize[1][0] - tdPosSize[0][0] == tbSize[0] - 1) {  \r\n            this.forEachRow((row, indexRow) => {\r\n                const td = this.getTdByMatrix(indexRow, matrix[1] - 1);\r\n                this.nanny.insertAfterTd(this.nanny.getRowByTd(this.dom, td), td, newInsertTd(indexRow, tdColIndex, row));\r\n            });\r\n        } else {\r\n            const tdDone = [];\r\n            this.forEachRow((row, indexRow) => {\r\n                const td = this.getTdByMatrix(indexRow, matrix[1] - 1);\r\n                if (tdDone.indexOf(td) == -1) {\r\n                    if (this.cellType(td) == this.CELL_NORMAL) {\r\n                        this.nanny.insertAfterTd(this.nanny.getRowByTd(this.dom, td), td, newInsertTd(indexRow, tdColIndex, row));\r\n                    } else {    // big cell\r\n                        this.nanny.setTdSpan(td, null, 1, true);\r\n                    }\r\n                    tdDone.push(td);\r\n                }\r\n            });\r\n        }\r\n        */\r\n        this.refresh();\r\n        return this;\r\n    }\r\n};"," // utils, a dog always hardworing.\r\n\r\nexport default {\r\n    tableClassName: '_table-butcher_',\r\n    init(table){\r\n        this.dom = table;\r\n    },\r\n    initObj(obj) {\r\n        this.dom = obj;\r\n    },\r\n\r\n    getSpan(td){\r\n        return [this.nanny.getTdRowSpan(td), this.nanny.getTdColSpan(td)];\r\n    },\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {*} td \r\n     * @returns [rowIndex, colIndex]\r\n     */\r\n    getTdIndex(td){\r\n        if (!td) return null;\r\n        const tr = this.nanny.getRowByTd(this.dom, td);\r\n        let rowIndex = -1,\r\n            colIndex = -1;\r\n        this.forEachRow((row, index)=>{\r\n            if (row === tr){\r\n                rowIndex = index;\r\n                return true;\r\n            }\r\n        });\r\n\r\n        const tds = this.nanny.getTdsInRow(tr);\r\n        tds.forEach((val, index)=>{\r\n            if (val === td){\r\n                colIndex = index;\r\n            }\r\n        });\r\n\r\n        return [rowIndex, colIndex];\r\n    },\r\n\r\n    getTdByIndex(tdRow, tdCol){\r\n        if (tdRow == -1 || tdCol == -1){\r\n            return null;\r\n        }\r\n        let inRow = -1, retTd;\r\n        this.forEachRow((row, index)=>{\r\n            if (tdRow == index){\r\n                inRow = row;\r\n                return true;\r\n            }\r\n        });\r\n        if (inRow == -1){\r\n            return null;\r\n        }else{\r\n            // retTd = inRow.querySelectorAll(':scope > td')[tdCol];\r\n            retTd = this.nanny.getTdsInRow(inRow)[tdCol];\r\n            return retTd;\r\n        }\r\n    },\r\n\r\n    // return [matRowIndex, matColIndex]\r\n    getTdMatrix(td) {\r\n        if (!td) return null;\r\n        return this.matrixTd2Mat(...this.getTdIndex(td));\r\n    },\r\n\r\n    getTdByMatrix(matRow, matCol) {\r\n        const tdIndex = this.matrixMat2Td(matRow, matCol);\r\n        if (tdIndex) {\r\n            return this.getTdByIndex(...tdIndex);\r\n        } else {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * calculate table rectangle size\r\n     * @return [rowSize, colSize]\r\n     */\r\n    getSize(){\r\n        let sizeCol = 0, me = this, allTdSize=[];\r\n        // find max column size\r\n        this.forEachRow((row, rowIndex)=>{\r\n            let thisRowSize = 0;\r\n            this.nanny.getTdsInRow(row).forEach((td, colIndex)=>{\r\n                let span = me.getSpan(td);\r\n                thisRowSize += span[1];\r\n            });\r\n            allTdSize.push(thisRowSize);\r\n        });\r\n        if (allTdSize.length > 0) {\r\n            sizeCol = Math.max(...allTdSize);\r\n        }\r\n        // this.forUnderTable( (td)=>{\r\n        //     let span = me.getSpan(td);\r\n        //     sizeCol += span[1];\r\n        // }, '> tr:first-child > td');\r\n        return [\r\n            this.nanny.getRowSize(this.dom),\r\n            sizeCol\r\n        ];\r\n    },\r\n\r\n    /**\r\n     * sort row by row\r\n     * @param {Array[TD]} tds \r\n     */\r\n    sort(arrTd){\r\n        let me = this;\r\n        arrTd.sort((a,b)=>{\r\n            let aPos = me.getTdIndex(a), // Do not mind.\r\n                bPos = me.getTdIndex(b); // Do not mind.\r\n            if (aPos[0] != bPos[0]){\r\n                return aPos[0] - bPos[0];\r\n            }else{\r\n                return aPos[1] - bPos[1];\r\n            }\r\n        })\r\n        return arrTd;\r\n    },\r\n\r\n    /**\r\n     * loop each td with tr and position detail\r\n     */\r\n    forEachCell(fn){\r\n        const fnTR = (tr, rowIndex)=>{\r\n            let tds = this.nanny.getTdsInRow(tr),\r\n                colIndex = 0;\r\n            for(let td of tds){\r\n                fn(td, rowIndex, colIndex, tr);\r\n                colIndex++;\r\n            }\r\n        };\r\n        // this.forUnderTable(fnTR, '> tr');\r\n        this.forEachRow(fnTR);\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param {fn}  receive arguments(element, index, all elements)\r\n     */\r\n    forEachRow(fn){\r\n        this.nanny.eachRow(this.dom, fn);\r\n    },\r\n\r\n\r\n    /**\r\n     * loop under the table\r\n     */\r\n    // forUnderTable(fn, selector = '> tr > td'){\r\n    //     let elements = this.dom.querySelectorAll(`:scope > tbody ` + selector);\r\n    //     let index = -1;\r\n    //     for(let el of elements){\r\n    //         index++;\r\n    //         if (true === fn(el, index, elements)){\r\n    //             return;\r\n    //         }\r\n    //     }\r\n    // },\r\n\r\n    /**\r\n     * loop with table matrix\r\n     * @param {function}    fn      invoke with argument (express number, row index, column index, row array)\r\n     */\r\n    forEachMatrix(fn){\r\n        let indexOfRow = -1,\r\n            indexOfCol = -1;\r\n        for(let row of this.matrix){\r\n            indexOfRow++;\r\n            indexOfCol = -1;\r\n            for(let col of row){\r\n                indexOfCol++;\r\n                if(true === fn(col, indexOfRow, indexOfCol, row)){\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * find the first same expression number in table matrix\r\n     * @param {integer} expNumber\r\n     */\r\n    findFirstTime(expNumber){\r\n        let ret = null;\r\n        this.forEachMatrix((val, row, col, arr)=>{\r\n            if (val === expNumber){\r\n                ret = [row, col];\r\n                return true;\r\n            }\r\n        });\r\n        return ret;\r\n    },\r\n\r\n    isTheFirstTd(td) {\r\n        const tdMatrix = this.getTdMatrix(td);\r\n        if (tdMatrix[1] == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    },\r\n    isTheLastTd(td) {\r\n        const tdMatrix = this.getTdMatrix(td);\r\n        const colSpan = this.nanny.getTdColSpan(td);\r\n        const size = this.getSize();\r\n        if (tdMatrix[1] + colSpan == size[1]) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    },\r\n    /**\r\n     * Check if it is the first TR\r\n     * Arguments tr and td need one, tr first.\r\n     * @param {*} tr\r\n     * @param {*} td \r\n     * @returns \r\n     */\r\n    isTheFirstTr(tr, td) {\r\n        let ret = false;\r\n        if (tr == null && td == null) { return null; }\r\n        if (tr) {\r\n            this.nanny.eachRow(this.dom, (row, rowIndex) => {\r\n                if (row == tr && rowIndex == 0) {\r\n                    ret = true;\r\n                }\r\n            });\r\n        } else {\r\n            const tdMatrix = this.getTdMatrix(td);\r\n            if (tdMatrix[0] == 0) {\r\n                ret = true;\r\n            }\r\n        }\r\n        return ret;\r\n    },\r\n    /**\r\n     * Check if it is the last TR\r\n     * Arguments tr and td need one, tr first.\r\n     * @param {*} tr\r\n     * @param {*} td \r\n     * @returns \r\n     */\r\n    isTheLastTr(tr, td) {\r\n        let ret = false;\r\n        if (tr == null && td == null) { return null; }\r\n        const size = this.getSize();\r\n        if (tr) {\r\n            this.nanny.eachRow(this.dom, (row, rowIndex) => {\r\n                if (row == tr && rowIndex + 1 == size[1]) {\r\n                    ret = true;\r\n                }\r\n            })\r\n        } else {\r\n            const area = this.getMatRectangeAreaByTd(td);\r\n            if (area[1][0] + 1 == size[0]) {\r\n                ret = true;\r\n            }\r\n        }\r\n        return ret;\r\n    },\r\n    findTheTdNext(td) {\r\n        if (this.isTheLastTd(td)) {\r\n            return null;\r\n        } else {\r\n            const tdMatrix = this.getTdMatrix(td);\r\n            const colSpan = this.nanny.getTdColSpan(td);\r\n            const ret = this.getTdByMatrix(tdMatrix[0], tdMatrix[1] + colSpan);\r\n            return ret;\r\n        }\r\n    },\r\n    findTheTdPrev(td) {\r\n        if (this.isTheFirstTd(td)) {\r\n            return null;\r\n        } else {\r\n            const tdMatrix = this.getTdMatrix(td);\r\n            const ret = this.getTdByMatrix(tdMatrix[0], tdMatrix[1] - 1);\r\n            return ret;\r\n        }\r\n    },\r\n    findTheTdAbove(td) {\r\n        if (this.isTheFirstTr(null, td)) {\r\n            return null;\r\n        } else {\r\n            const tdMatrix = this.getTdMatrix(td);\r\n            const ret = this.getTdByMatrix(tdMatrix[0] - 1, tdMatrix[1]);\r\n            return ret;\r\n        }\r\n    },\r\n    findTheTdUnder(td) {\r\n        if (this.isTheLastTr(null, td)) {\r\n            return null;\r\n        } else {\r\n            const area = this.getMatRectangeAreaByTd(td);\r\n            const ret = this.getTdByMatrix(area[1][0] + 1, area[0][1]);\r\n            return ret;\r\n        }\r\n    }\r\n};","export default {\r\n\tnewTd: () => document.createElement('td'),\r\n\tdelTd: (row, td) => row.removeChild(td),\r\n\tnewTr: () => document.createElement('tr'),\r\n\tdelTr: (table, row) => table.childNodes[0].removeChild(row),\r\n\r\n\tgetTdRowSpan: (obj) => obj.rowSpan,\r\n\tgetTdColSpan: (obj) => obj.colSpan,\r\n\tgetRowByIndex: (table, index) => table.childNodes[0].childNodes[index],\r\n\tgetRowByTd(table, td){\r\n\t\tlet ret = null;\r\n\t\tthis.eachRow(table, (row) => {\r\n\t\t\tconst index = Array.prototype.indexOf.call(row.childNodes, td);\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tret = row\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn ret;\r\n\t},\r\n\t// return array\r\n\tgetTdsInRow: (row) => row.childNodes,\r\n\tgetTdInRow: (row, index) => row.childNodes[index],\r\n\tgetRowSize: (table) => {\r\n\t\tif (table && table.childNodes && table.childNodes.length > 0) {\r\n\t\t\treturn table.childNodes[0].childNodes.length;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t},\r\n\teachRow:(table, fn) => {\r\n\t\tif (table && table.childNodes && table.childNodes.length > 0) {\r\n\t\t\ttable.childNodes[0].childNodes.forEach(fn)\r\n\t\t}\r\n\t},\r\n\r\n\tinsertEmptyRow: (table, index) => table.insertRow(index),\r\n\tinsertRowBefore: (table, row, newRow) => row.before(newRow),\r\n\tinsertBeforeTd: (row, td, newEl) => td.before(newEl),\r\n\tinsertAfterTd: (row, td, newEl) => td.after(newEl),\r\n\tappendTd: (tr, el) => tr.appendChild(el),\r\n\tmoveTdChilds: (tdSource, tdTarget) => {\r\n\t\tif (!tdSource || !tdSource.childNodes || tdSource.childNodes.length == 0) { return }\r\n\t\ttdSource.childNodes.forEach(node => tdTarget.append(node))\r\n\t},\r\n\r\n\t/**\r\n\t * @param {Element} td \t\t\tTD\r\n\t * @param {Number} rowSpan \t\ttd rowSpanoffset=truerowSpan\r\n\t * @param {Number} colSpan \t\ttd colSpanoffset=truecolSpan\r\n\t * @param {Boolean} offset \t\t\r\n\t */\r\n\tsetTdSpan(td, rowSpan, colSpan, offset = false){\r\n\t\tif (rowSpan !== null) {\r\n\t\t\tif (offset) {\r\n\t\t\t\ttd.rowSpan += rowSpan;\r\n\t\t\t} else {\r\n\t\t\t\ttd.rowSpan = rowSpan;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (colSpan !== null) {\r\n\t\t\tif (offset) {\r\n\t\t\t\ttd.colSpan += colSpan;\r\n\t\t\t} else {\r\n\t\t\t\ttd.colSpan = colSpan;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn td;\r\n\t}\r\n}\r\n\r\n/*\r\nfix keyword:\r\ncolSpan, rowSpan,\r\nparentNode\r\nappendChild, append\r\nbefore, after\r\ndocument, createElement\r\n*/","import father from './father';\r\nimport mother from './mother';\r\nimport liLei from './liLei';\r\nimport hanMeiMei from './hanMeiMei';\r\nimport puppy from './puppy';\r\nimport nannyDom from './nannyDom';\r\n\r\n// output layer\r\nlet diapason = {\r\n    dom: null,\r\n    ...father,\r\n    ...mother,\r\n    ...liLei,\r\n    ...hanMeiMei,\r\n    ...puppy\r\n};\r\n\r\n// entry class\r\nconst TableBuster = function(table){ \r\n    this.nanny = nannyDom;\r\n    this.init(table);\r\n    this.buildMatrix();\r\n};\r\nconst TableObjectBuster = function (nannyObj) {\r\n    this.nanny = nannyObj;\r\n    this.init = function(object) {\r\n        this.initObj(object);\r\n        this.buildMatrix();\r\n    };\r\n};\r\n// Object.assign(diapason, father, mother, liLei, hanMeiMei, puppy);\r\nTableBuster.prototype = diapason;\r\nTableObjectBuster.prototype = diapason;\r\n\r\nexport { TableObjectBuster, TableBuster };\r\n\r\nwindow.TableBuster = TableBuster;\r\nwindow.TableObjectBuster = TableObjectBuster;\r\n// export default TableBuster;"]}