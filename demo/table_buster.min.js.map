{"version":3,"sources":["father.js","mother.js","liLei.js","hanMeiMei.js","puppy.js","nannyDom.js","home.js"],"names":["split","td","decorater","getSpan","spanRow","spanCol","nanny","setTdSpan","spanIndexCol","row","getRowByTd","dom","insertAfterTd","newTd","spanIndexRow","arrTdIndex","getTdIndex","arrTdMatrix","getTdMatrix","tr","getRowByIndex","tds","getTdsInRow","firstTdMatrix","length","Number","MAX_VALUE","appendTd","index","tdFound","tdFoundMatrix","insertBeforeTd","refresh","deleteColumn","tdColCount","tdColMatrix","tdColSpan","getTdColSpan","deleteColumnHandler","rowIndex","tdDone","tbSize","getSize","getTdByMatrix","indexOf","span","delTd","push","rowSpan","getTdRowSpan","deleteRow","tdRowCount","tdRowMatrix","tdRowSpan","deleteRowHandler","colIndex","nextTr","tdMarkShort","cellType","CELL_BIG_HEAD","nextTdColMatrix","nextRowTd","CELL_BIG","forEach","delTr","merge","tdFrom","tdTo","selectionTd","selectionByTd","arrTdInArea","area","matFrom","matTo","colSpan","firstTd","shift","moveTdChilds","findAreaTd","selection","queue","tdFromPosition","getMatRectangeAreaByTd","tdFromAndEndPosition","me","matrixForInArea","num","newFound","newArea","concat","tdArea","cellCanCount","findFirstNumberPosition","sort","_refreshTimeout","CELL_NORMAL","matrix","buildMatrix","sizeRow","sizeCol","tmpRow","maxFillNumber","arr","Array","from","repeat","map","v","forEachCell","matrixTd2Mat","matRow","matCol","fillBigInMat","matrixFor","fn","col","ret","rowLoop","Math","min","max","colLoop","iRow","iCol","tdRow","tdCol","matRowArr","tdColIndex","retMatCol","expNumber","matColIndex","matrixMat2Td","loopColIndex","startMatRow","startMatCol","cellSpan","indexRow","m","indexCol","endRow","endCol","matRowOrTd","number","arguments","tmpNum","targetNum","getBigCellSize","startNumber","startPos","numberSearch","maxRowBefore","maxColBefore","arrTd","arrMat","getMatRectangeArea","mats","mat","areaJoin","pop","addCellToAllRow","sizeCell","forEachRow","insertRow","beforeTd","tdRowIndex","trHolder","newTr","fnAddTd","cellIndex","sizeIndex","size","tdInRow","insertRowBefore","addNewRow","colCount","rowCount","insertEmptyRow","insertCell","beforeThisTd","newInsertTd","getTdInRow","tableClassName","init","table","initObj","obj","val","getTdByIndex","inRow","allTdSize","thisRowSize","getRowSize","a","b","aPos","bPos","eachRow","forEachMatrix","indexOfRow","indexOfCol","findFirstTime","document","createElement","removeChild","childNodes","prototype","call","newRow","before","newEl","after","el","appendChild","tdSource","tdTarget","node","append","offset","diapason","father","mother","liLei","hanMeiMei","puppy","TableBuster","nannyDom","TableObjectBuster","nannyObj","object","window"],"mappings":"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","file":"table_buster.min.js","sourceRoot":"../src","sourcesContent":["// strong man\r\n/*\r\n\r\n*/\r\nexport default {\r\n    split(td, decorater) {\r\n        if (!td) return;\r\n        if (!decorater) decorater = (td) => td;\r\n        let [spanRow, spanCol] = this.getSpan(td);\r\n        if (spanRow > 1 || spanCol > 1) {\r\n            this.nanny.setTdSpan(td, 1, 1);\r\n            // row 1\r\n            let spanIndexCol = spanCol - 1;\r\n            while (spanIndexCol > 0) {\r\n                const row = this.nanny.getRowByTd(this.dom, td);\r\n                this.nanny.insertAfterTd(\r\n                    row,\r\n                    td,\r\n                    decorater(this.nanny.newTd(), 0, spanIndexCol - 1, this.dom, row)\r\n                );\r\n                spanIndexCol--;\r\n            }\r\n            // other row\r\n            let spanIndexRow = spanRow - 1 - 1;\r\n            const arrTdIndex = this.getTdIndex(td);\r\n            const arrTdMatrix = this.getTdMatrix(td);\r\n            while (spanIndexRow >= 0) {\r\n                spanIndexCol = spanCol - 1;\r\n                const tr = this.nanny.getRowByIndex(this.dom, arrTdIndex[0] + (spanRow - 1 - spanIndexRow));\r\n                const tds = this.nanny.getTdsInRow(tr);\r\n                const firstTdMatrix = tds.length > 0 ? this.getTdMatrix(tds[0]) : Number.MAX_VALUE;\r\n                /*\r\n                    1. The td ready to merge was on the first cell index.\r\n                    2. The row was empty.\r\n                    3. The first td in the row must be after the td which ready to insert.\r\n                 */\r\n                if (arrTdMatrix[0] == 0 && tds.length == 0 && firstTdMatrix[1] <= arrTdMatrix[1]) {\r\n                    while (spanIndexCol >= 0) {\r\n                        this.nanny.appendTd(\r\n                            tr,\r\n                            decorater(\r\n                                this.nanny.newTd(),\r\n                                spanRow - 1 - spanIndexRow,\r\n                                spanCol - 1 - spanIndexCol,\r\n                                this.dom,\r\n                                tr\r\n                            )\r\n                        );\r\n                        spanIndexCol--;\r\n                    }\r\n                } else {\r\n                    for (let index = 0; index < tds.length; index++) {\r\n                        const tdFound = tds[index];\r\n                        const tdFoundMatrix = this.getTdMatrix(tdFound);\r\n                        if (tdFoundMatrix[1] > arrTdMatrix[1]) {\r\n                            while (spanIndexCol >= 0) {\r\n                                this.nanny.insertBeforeTd(\r\n                                    tr,\r\n                                    tdFound,\r\n                                    decorater(\r\n                                        this.nanny.newTd(),\r\n                                        spanRow - 1 - spanIndexRow,\r\n                                        spanCol - 1 - spanIndexCol,\r\n                                        this.dom,\r\n                                        tr\r\n                                    )\r\n                                );\r\n                                spanIndexCol--;\r\n                            }\r\n                            break;\r\n                        } else if (index + 1 == tds.length) {   // last position\r\n                            while (spanIndexCol >= 0) {\r\n                                this.nanny.insertAfterTd(\r\n                                    tr,\r\n                                    tdFound,\r\n                                    decorater(\r\n                                        this.nanny.newTd(),\r\n                                        spanRow - 1 - spanIndexRow,\r\n                                        spanIndexCol - 1,\r\n                                        this.dom,\r\n                                        tr\r\n                                    )\r\n                                );\r\n                                spanIndexCol--;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                spanIndexRow--;\r\n            }\r\n        }\r\n        this.refresh();\r\n    },\r\n\r\n    deleteColumn(td) {\r\n        if (!td) return;\r\n        // const size = td.colSpan;\r\n        const [tdRowMatrix, tdColMatrix] = this.getTdMatrix(td);\r\n        const tdColSpan = this.nanny.getTdColSpan(td);\r\n        let tdColCount = 0;\r\n\r\n        while (tdColCount < tdColSpan) {\r\n            this.deleteColumnHandler(tdColMatrix);\r\n            this.refresh();\r\n            tdColCount++;\r\n        }\r\n    },\r\n\r\n    deleteColumnHandler(tdColMatrix) {\r\n        const tdDone = [];\r\n        const tbSize = this.getSize();\r\n        let rowIndex = 0;\r\n\r\n        while (rowIndex < tbSize[0]) {\r\n            const tdFound = this.getTdByMatrix(rowIndex, tdColMatrix);\r\n            if (tdFound && tdDone.indexOf(tdFound) == -1) {\r\n                let span = this.nanny.getTdColSpan(tdFound);\r\n                if (span > 1) {\r\n                    this.nanny.setTdSpan(tdFound, null, span - 1);\r\n                } else {\r\n                    this.nanny.delTd(this.nanny.getRowByIndex(this.dom, rowIndex), tdFound);\r\n                }\r\n                tdDone.push(tdFound);\r\n                // fix some td rowSpan greater than 1, and delete wrong TDs in the next row.\r\n                const rowSpan = this.nanny.getTdRowSpan(tdFound);\r\n                if (rowSpan > 1) {\r\n                    rowIndex += rowSpan;\r\n                    continue;\r\n                }\r\n            }\r\n            rowIndex++;\r\n        }\r\n    },\r\n    \r\n    deleteRow(td) {\r\n        if (!td) return;\r\n        const [tdRowMatrix, tdColMatrix] = this.getTdMatrix(td);\r\n\r\n        const tdRowSpan = this.nanny.getTdRowSpan(td);\r\n        let tdRowCount = 0;\r\n        while (tdRowCount < tdRowSpan) {\r\n            this.deleteRowHandler(tdRowMatrix);\r\n            this.refresh();\r\n            tdRowCount++;\r\n        }\r\n    },\r\n\r\n    deleteRowHandler(tdRowMatrix) {\r\n        const tr = this.nanny.getRowByIndex(this.dom, tdRowMatrix);\r\n        // const nextTr = tr.nextElementSibling;\r\n        const nextTr = this.nanny.getRowByIndex(this.dom, tdRowMatrix + 1);\r\n        const tbSize = this.getSize();\r\n        let colIndex = 0;\r\n        const tdMarkShort = [];\r\n        while (colIndex < tbSize[1]) {\r\n            const cellType = this.cellType(tdRowMatrix, colIndex);\r\n\r\n            // \r\n            if (cellType == this.CELL_BIG_HEAD) {\r\n                const tdFound = this.getTdByMatrix(tdRowMatrix, colIndex);\r\n                const tdRowSpan = this.nanny.getTdRowSpan(tdFound);\r\n                const tdColSpan = this.nanny.getTdColSpan(tdFound);\r\n                // move tdFound to next tr\r\n                if (tdRowSpan > 1 && tbSize[0] != tdRowMatrix) {\r\n                    let nextTdColMatrix = colIndex + tdColSpan;\r\n                    while (nextTdColMatrix < tbSize[1]) {\r\n                        const nextRowTd = this.getTdByMatrix(tdRowMatrix + 1, nextTdColMatrix);\r\n                        const row = this.nanny.getRowByIndex(this.dom, tdRowMatrix + 1);\r\n                        if (row == nextTr) {\r\n                            // nextRowTd.before(tdFound);\r\n                            this.nanny.insertBeforeTd(row, nextRowTd, tdFound);\r\n                            break;\r\n                        }\r\n                        nextTdColMatrix++;\r\n                    }\r\n                    const tdFoundInRow = this.nanny.getRowByTd(tdFound);\r\n                    if (tdFoundInRow != nextTr && nextTr) {\r\n                        this.nanny.appendTd(nextTr, tdFound);\r\n                    }\r\n                    // make sure short it.\r\n                    this.nanny.setTdSpan(tdFound, -1, null, true);\r\n                    // tdFound.rowSpan--;\r\n                    this.refresh();\r\n                }\r\n\r\n                // colIndex += tdFound.colSpan;\r\n                colIndex += tdColSpan;\r\n            } else if(cellType == this.CELL_BIG) {\r\n                const tdFound = this.getTdByMatrix(tdRowMatrix, colIndex);\r\n                tdMarkShort.push(tdFound);\r\n                this.refresh();\r\n                const tdColSpan = this.nanny.getTdColSpan(tdFound);\r\n                // colIndex += tdFound.colSpan;\r\n                colIndex += tdColSpan;\r\n            } else {\r\n                colIndex++;\r\n            }\r\n        }\r\n        tdMarkShort.forEach((td) => this.nanny.setTdSpan(td, -1, null, true));\r\n        this.nanny.delTr(this.dom, tr);\r\n    }\r\n};","// merge, nice women\r\nexport default {\r\n    /**\r\n     * \r\n     * @param {Element} tdFrom \r\n     * @param {Element} tdTo \r\n     */\r\n    merge(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let selectionTd = this.selectionByTd(tdFrom, tdTo),\r\n            arrTdInArea = selectionTd.td,\r\n            [matFrom, matTo] = selectionTd.area,\r\n            rowSpan = matTo[0] - matFrom[0] + 1,\r\n            colSpan = matTo[1] - matFrom[1] + 1,\r\n            firstTd = arrTdInArea.shift();\r\n        \r\n        // remove node\r\n        arrTdInArea.forEach((td, index)=>{\r\n            this.nanny.moveTdChilds(td, firstTd);\r\n            const tr = this.nanny.getRowByTd(this.dom, td);\r\n            this.nanny.delTd(tr, td);\r\n        });\r\n\r\n        // merge node\r\n        this.nanny.setTdSpan(firstTd, rowSpan, colSpan);\r\n        // firstTd.rowSpan = rowSpan;\r\n        // firstTd.colSpan = colSpan;\r\n\r\n        this.refresh();\r\n    },\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {Element} tdFrom \r\n     * @param {Element} tdTo \r\n     */\r\n    findAreaTd(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let selection = this.selectionByTd(tdFrom, tdTo);\r\n        return selection.td;\r\n    },\r\n\r\n\r\n\r\n\r\n    /**\r\n     * All TDs in rectange selection.\r\n     * @param {Element} tdFrom\r\n     * @param {Element} tdTo\r\n     */\r\n    selectionByTd(tdFrom, tdTo) {\r\n        if (tdFrom == null && tdTo == null) return;\r\n        else if (tdFrom == null) tdFrom = tdTo;\r\n        else if (tdTo == null) tdTo = tdFrom;\r\n        let queue = [tdFrom, tdTo],\r\n            index = 0,\r\n            tdFromPosition = this.getMatRectangeAreaByTd(tdFrom),\r\n            tdFromAndEndPosition = this.getMatRectangeAreaByTd(tdFrom, tdTo),\r\n            area = [\r\n                tdFromPosition[0][0], tdFromPosition[0][1],  // left top\r\n                tdFromPosition[1][0], tdFromPosition[1][1]   // right bottom\r\n            ],\r\n            me = this;\r\n\r\n\r\n        // find other TD inner area\r\n        // TODO: can be optimized.\r\n        this.matrixForInArea(\r\n            tdFromAndEndPosition[0], tdFromAndEndPosition[1], \r\n            (num, rowIndex, colIndex)=>{\r\n                let td = me.getTdByMatrix(rowIndex, colIndex);\r\n                if (queue.indexOf(td) == -1){\r\n                    queue.push(td);\r\n                }\r\n            }\r\n        );\r\n\r\n        // find big cell expand\r\n        while(index < queue.length){\r\n            let newFound = false,\r\n                newArea = area.concat(),\r\n                tdArea = this.getMatRectangeAreaByTd(queue[index]);\r\n\r\n            if (tdArea[0][0] < newArea[0]){\r\n                newArea[0] = tdArea[0][0];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[0][1] < newArea[1]){\r\n                newArea[1] = tdArea[0][1];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[1][0] > newArea[2]){\r\n                newArea[2] = tdArea[1][0];\r\n                newFound = true;\r\n            }\r\n            if (tdArea[1][1] > newArea[3]){\r\n                newArea[3] = tdArea[1][1];\r\n                newFound = true;\r\n            }\r\n\r\n            if (newFound == true){\r\n                let me = this;\r\n                this.matrixForInArea(\r\n                    [newArea[0], newArea[1]],\r\n                    [newArea[2], newArea[3]],\r\n                    (num, rowIndex, colIndex)=>{\r\n                        if (rowIndex < area[0] || rowIndex > area[2] || colIndex < area[1] || colIndex > area[3]){ // out of the past area \r\n                            // find head unit of big cell\r\n                            if (me.cellCanCount(rowIndex, colIndex) == false){\r\n                                [rowIndex, colIndex] = me.findFirstNumberPosition(rowIndex, colIndex);\r\n                                if (rowIndex == -1 || colIndex == -1)\r\n                                    return;    \r\n                            }\r\n                            let td = me.getTdByMatrix(rowIndex, colIndex);\r\n                            if (queue.indexOf(td) == -1){\r\n                                queue.push(td);\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n                area = newArea;\r\n            }\r\n            index++;\r\n        }\r\n        queue = this.sort(queue);\r\n        return {td:queue, area: [[area[0], area[1]], [area[2], area[3]]]};\r\n    },\r\n\r\n};","// A creative boy\r\n// something about table matrix\r\nlet _refreshTimeout = 0;\r\nexport default {\r\n    /*\r\n\r\n    table expression\r\n    0 0 0\r\n    0 0 0\r\n    0 0 0\r\n\r\n    every number point to a td position.\r\n    0 is a normal td, other number is a large td's placehodler.\r\n    As a big cell, it place all the same number to mark the position, \r\n    except the first place. for example '3', first number will be '-3'.\r\n\r\n    example:\r\n    0 -1 1 0\r\n    0 1 1 0\r\n\r\n    <table>\r\n        <tr>\r\n            <td></td>\r\n            <td colspan=\"2\" rowspan=\"2\"></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n    </table>\r\n\r\n    */\r\n    CELL_NORMAL       : 0,\r\n    CELL_BIG          : 1,\r\n    CELL_BIG_HEAD     : 2,\r\n    matrix:[[]],\r\n    refresh(){\r\n        // let time = +new Date();\r\n        // window.clearTimeout(_refreshTimeout);\r\n        // _refreshTimeout = window.setTimeout(() => this.buildMatrix(), 300);\r\n        this.buildMatrix();\r\n        // console.log(`refresh time use: ${(+new Date() - time)}ms`);\r\n    },\r\n\r\n\r\n    buildMatrix(){\r\n        let [sizeRow, sizeCol] = this.getSize(),\r\n            tmpRow = sizeRow,\r\n            maxFillNumber = 1; \r\n        // fill zero at all\r\n        this.matrix = [];\r\n        while(tmpRow > 0){\r\n            const arr = Array.from('0'.repeat(sizeCol)).map(v => +v);\r\n            this.matrix.push(arr);\r\n            tmpRow--;\r\n        }\r\n        // recognize big cell\r\n        this.forEachCell((td, rowIndex, colIndex, tr) => {\r\n            let [rowSpan, colSpan] = this.getSpan(td);\r\n            let [matRow, matCol] = this.matrixTd2Mat(rowIndex, colIndex);\r\n            // checkout big cell and fill number\r\n            if (rowSpan > 1 || colSpan > 1){\r\n                // count actual column index\r\n                this.fillBigInMat(maxFillNumber, matRow, matCol, rowSpan, colSpan);\r\n                maxFillNumber++;\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * \r\n     * @param {Function} fn (number, rowIndex, colIndex)\r\n     */\r\n    matrixFor(fn){\r\n        let rowIndex = 0, colIndex = 0, ret;\r\n        for(let row of this.matrix){\r\n            colIndex = 0;\r\n            for(let col of row){\r\n                ret = fn(col, rowIndex, colIndex);\r\n                if(ret == true)\r\n                    return col;\r\n                colIndex++;\r\n            }\r\n            rowIndex++;\r\n        }\r\n    },\r\n\r\n\r\n    matrixForInArea(matFrom , matTo, fn){\r\n        let rowLoop = [Math.min(matFrom[0], matTo[0]), Math.max(matFrom[0], matTo[0])],\r\n            colLoop = [Math.min(matFrom[1], matTo[1]), Math.max(matFrom[1], matTo[1])];\r\n        \r\n        for(let iRow = rowLoop[0]; iRow <= rowLoop[1]; iRow++){\r\n            for(let iCol = colLoop[0]; iCol <= colLoop[1]; iCol++){\r\n                if (fn(this.matrix[iRow][iCol], iRow, iCol) === true){\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n\r\n    // change axis\r\n    matrixTd2Mat(tdRow, tdCol){\r\n        let matRow = tdRow,\r\n            matRowArr = this.matrix[tdRow],\r\n            tdColIndex = -1,\r\n            retMatCol = -1,\r\n            me = this;\r\n        matRowArr.forEach((expNumber, matColIndex)=>{\r\n            if (me.cellCanCount(matRow, matColIndex)){\r\n                tdColIndex++;\r\n            }\r\n            if (retMatCol == -1 && tdColIndex === tdCol){\r\n                retMatCol = matColIndex;\r\n            }\r\n        });\r\n        return [matRow, retMatCol];\r\n    },\r\n\r\n\r\n    // change axis\r\n    matrixMat2Td(matRow, matCol){\r\n        if (this.cellType(matRow, matCol) === this.CELL_BIG){\r\n            [matRow, matCol] = this.findFirstNumberPosition(matRow, matCol);\r\n        }\r\n        let loopColIndex = 0, \r\n            tdRow = matRow,\r\n            tdCol = -1;\r\n        while(loopColIndex <= matCol){\r\n            if (this.cellCanCount(matRow, loopColIndex)){\r\n                tdCol++;\r\n            } \r\n            loopColIndex++;\r\n        }\r\n        return [tdRow, tdCol];\r\n        // matrix number\r\n        // let number = this.matrix[matRow][matCol],\r\n        //     count = -1;\r\n        // if (this.cellCanCount(matRow, matCol)){\r\n        //     count++;\r\n        // }else{\r\n\r\n        // }\r\n        // try{\r\n        //     number = ;\r\n        // }catch(e){\r\n        //     console.log(`matrixMat2Td fail. ${matRow}, ${matCol} overload.`);\r\n        //     console.log(e);\r\n        //     return null;\r\n        // }\r\n\r\n    },\r\n\r\n\r\n\r\n    // in big cell area, fill number in it, except first number was multiply -1\r\n    fillBigInMat(expNumber, startMatRow, startMatCol, rowSpan, cellSpan){\r\n        let m = this.matrix;\r\n        let endRow = startMatRow + rowSpan - 1,\r\n            endCol = startMatCol + cellSpan - 1,\r\n            indexRow = startMatRow, \r\n            indexCol;\r\n        while(indexRow <= endRow){\r\n            indexCol = startMatCol;\r\n            while(indexCol <= endCol){\r\n                m[indexRow][indexCol] = expNumber;\r\n                indexCol++;\r\n            }\r\n            indexRow++;\r\n        }\r\n        // rewrite first number\r\n        m[startMatRow][startMatCol] = -1 * expNumber;\r\n    },\r\n\r\n\r\n    // return [0,1,2]\r\n    //   0: not a big cell\r\n    //   1: is a big cell, not the first place\r\n    //   2: is a big cell and is the first place\r\n    cellType(matRowOrTd, matCol){\r\n        let number = null, ret;\r\n        \r\n        if (matCol == null){\r\n            // argument was td\r\n            if (typeof matRowOrTd == 'number') {\r\n                number = matRowOrTd;\r\n            } else {\r\n                [matRowOrTd, matCol] = this.matrixTd2Mat(...this.getTdIndex(matRowOrTd));\r\n            }\r\n        }\r\n        \r\n        if (number == null && matCol != null){\r\n            number = this.matrix[matRowOrTd][matCol];\r\n        }\r\n\r\n        number = +number;\r\n        if (number == 0){\r\n            ret = this.CELL_NORMAL;\r\n        }else if(number > 0){\r\n            ret = this.CELL_BIG;\r\n        }else{\r\n            ret = this.CELL_BIG_HEAD;\r\n        }\r\n        \r\n        return ret;\r\n    },\r\n\r\n\r\n    // judge the cell single or belong to big cell for that can not be count.\r\n    cellCanCount(matRow, matCol){\r\n        let type = this.cellType(...arguments);\r\n        // If matrix unit number is not bigger than 0, it will specify to a true td.\r\n        if (this.CELL_BIG != this.cellType(matRow, matCol)){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * td in matrix return matrix number of the head\r\n     * @param {Array(x,y)} matRow \r\n     * @param {Array(x,y)} matCol \r\n     */\r\n    findFirstNumberPosition(matRow, matCol){\r\n        let m = this.matrix,\r\n            number = this.matrix[matRow][matCol];\r\n\r\n        if (this.CELL_BIG == this.cellType(matRow, matCol)){\r\n            let rowIndex = matRow,\r\n                colIndex = matCol,\r\n                tmpNum = m[rowIndex][colIndex],\r\n                targetNum = -1 * number;\r\n\r\n            // move left in row\r\n            while(colIndex >= 0){\r\n                tmpNum = m[rowIndex][colIndex];\r\n                if (tmpNum == targetNum){\r\n                    return [rowIndex, colIndex];\r\n                }else if(tmpNum == number){\r\n                    colIndex--;\r\n                }else{\r\n                    // our of range, move up.\r\n                    colIndex++;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            colIndex = colIndex < 0 ? 0 : colIndex;\r\n            rowIndex--;\r\n            \r\n            // move up in col\r\n            while(rowIndex >= 0){\r\n                tmpNum = m[rowIndex][colIndex];\r\n                if (tmpNum == targetNum){\r\n                    return [rowIndex, colIndex];\r\n                }else if(tmpNum == number){\r\n                    rowIndex--;\r\n                }else{\r\n                    // out of range\r\n                    break;\r\n                }\r\n            }\r\n            // can not found, return [-1, -1].\r\n            return [-1, -1]\r\n        }else{\r\n            return [matRow, matCol];\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * find cell in matrix axis, and recognize all cell area in matrix axis, \r\n     * return the start and end.\r\n     * @param {Array(x,y)} matRow \r\n     * @param {Array(x,y)} matCol \r\n     */\r\n    getBigCellSize(matRow, matCol){\r\n        let number = this.matrix[matRow][matCol],\r\n            startNumber;\r\n        let startPos = [], endPos = [];\r\n        if (this.cellType(number) == this.CELL_NORMAL){\r\n            return [[matRow, matCol], [matRow, matCol]];\r\n        }else if (this.cellType(number) == this.CELL_BIG_HEAD){\r\n            startNumber = number;\r\n            number = -1 * number;\r\n            startPos = [matRow, matCol];\r\n        }else{\r\n            startNumber = -1 * number;\r\n\r\n            // findout start position\r\n            this.matrixFor((numberSearch, rowIndex, colIndex)=>{\r\n                if (numberSearch == startNumber){\r\n                    startPos = [rowIndex, colIndex];\r\n                }\r\n            });\r\n        }\r\n\r\n        // find out end position\r\n        let iRow = matRow, iCol = matCol, iNumber,\r\n            maxRowBefore = this.matrix.length - 1,\r\n            maxColBefore = this.matrix[0].length - 1;\r\n        // search by row\r\n        while(iRow <= maxRowBefore - 1){\r\n            iNumber = this.matrix[iRow+1][iCol];\r\n            if (number != iNumber){\r\n                break;\r\n            }\r\n            iRow++;\r\n        }\r\n        // search by col\r\n        while(iCol <= maxColBefore - 1){\r\n            iNumber = this.matrix[iRow][iCol+1];\r\n            if (number != iNumber){\r\n                break;\r\n            }\r\n            iCol++;\r\n        }\r\n        endPos = [iRow, iCol];\r\n\r\n        return [startPos, endPos];\r\n    },\r\n\r\n\r\n    /**\r\n     * get all matrix unit of which was by TD holding\r\n     * @param  {...any} arrTd \r\n     */\r\n    getMatRectangeAreaByTd(...arrTd){\r\n        let me = this,\r\n            arrMat = [];\r\n        arrTd.forEach(\r\n            (td)=>{\r\n                if (!td) return;\r\n                if (me.cellType(td) == me.CELL_NORMAL){\r\n                    arrMat.push(me.matrixTd2Mat(...me.getTdIndex(td)));\r\n                }else{\r\n                    arrMat.push(...me.getBigCellSize(...me.matrixTd2Mat(...me.getTdIndex(td))));\r\n                }\r\n            }\r\n        );\r\n        return this.getMatRectangeArea(...arrMat);\r\n    },\r\n\r\n\r\n    /**\r\n     * give some matrix axis, return all matrix unit of which was by TD there.\r\n     * @param  {...any} mats \r\n     */\r\n    getMatRectangeArea(...mats){\r\n        let area = [\r\n                [mats[0][0], mats[0][1]],\r\n                [mats[0][0], mats[0][1]]\r\n            ],\r\n            mat,\r\n            areaJoin;\r\n        mats.shift();\r\n\r\n        while(mats.length > 0){\r\n            mat = mats.pop();\r\n            if (this.cellType(...mat) == this.CELL_NORMAL){\r\n                areaJoin = [mat,mat];\r\n            }else{\r\n                areaJoin = this.getBigCellSize(...mat);\r\n            }\r\n\r\n            // expand area with the other.\r\n            area = [\r\n                    [Math.min(area[0][0], areaJoin[0][0]), Math.min(area[0][1], areaJoin[0][1])],\r\n                    [Math.max(area[1][0], areaJoin[1][0]), Math.max(area[1][1], areaJoin[1][1])]\r\n                ];\r\n        }\r\n\r\n        return area;\r\n    },\r\n};","// tidy girl\r\n// append column or row\r\nexport default {\r\n    addCellToAllRow(fn){\r\n        let [sizeRow, sizeCell] = this.getSize();\r\n        this.forEachRow((row, rowIndex)=>{\r\n            let td = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(td, rowIndex, sizeCell, this.dom, row);\r\n                retFn && td == retFn;\r\n            }\r\n            this.nanny.appendTd(row, td);\r\n        });\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    // can recognize each big cell, and expand them by increase their colspan.\r\n    insertRow(beforeTd, fn){\r\n        const [tdRowIndex, tdColIndex] = this.getTdIndex(beforeTd);\r\n        let [sizeRow, sizeCell] = this.getSize();\r\n        const trHolder = this.nanny.newTr();\r\n\r\n        const fnAddTd = (cellIndex) => {\r\n            let td = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(td, tdRowIndex, cellIndex, this.dom, trHolder);\r\n                retFn && td == retFn;\r\n            }\r\n            this.nanny.appendTd(trHolder, td);\r\n        };\r\n\r\n        // first row.\r\n        if (tdRowIndex == 0) {\r\n            let cellIndex = 0;\r\n            while (cellIndex < sizeCell) {\r\n                fnAddTd(cellIndex);\r\n                cellIndex++;\r\n            }\r\n        } else {\r\n            // const tdBase = [];          // create row upon which TD.\r\n            let sizeIndex = 0;\r\n\r\n            while (sizeIndex < sizeCell) {\r\n                const tdFound = this.getTdByMatrix(tdRowIndex, sizeIndex);\r\n                const cellType = this.cellType(tdRowIndex, sizeIndex);\r\n                const colSpan = this.nanny.getTdColSpan(tdFound);\r\n                if (cellType == this.CELL_NORMAL) {\r\n                    fnAddTd(sizeIndex);\r\n                    sizeIndex++;\r\n                } else if (cellType == this.CELL_BIG_HEAD) {\r\n                    let size = colSpan;\r\n                    while (size > 0) {\r\n                        fnAddTd(sizeIndex);\r\n                        size--;\r\n                    }\r\n                    sizeIndex += colSpan;\r\n                } else if (cellType == this.CELL_BIG_HEAD || cellType == this.CELL_BIG) {\r\n                    this.nanny.setTdSpan(tdFound, 1, null, true);\r\n                    sizeIndex += colSpan;\r\n                }\r\n            }\r\n        }\r\n        const tdInRow = this.nanny.getRowByTd(this.dom, beforeTd);\r\n        this.nanny.insertRowBefore(this.dom, tdInRow, trHolder);\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    addNewRow(fn){\r\n        let [rowCount, colCount] = this.getSize();\r\n        const newTr = this.nanny.insertEmptyRow(this.dom, rowCount);\r\n        let index = 0;\r\n        while(colCount>0){\r\n            let newTd = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(newTd, rowCount, index, this.dom, newTr);\r\n                retFn && newTd == retFn;\r\n            }\r\n            this.nanny.appendTd(newTr, newTd);\r\n            colCount--;\r\n            index++;\r\n        }\r\n        this.refresh();\r\n        return this;\r\n    },\r\n    insertCell(beforeThisTd, fn){\r\n        let [tdRowIndex, tdColIndex] = this.getTdIndex(beforeThisTd);\r\n\r\n        let newInsertTd = (rowIndex, cellIndex, row) => {\r\n            let newTd = this.nanny.newTd();\r\n            if (fn) {\r\n                const retFn = fn(newTd, rowIndex, cellIndex, this.dom, row);\r\n                retFn && newTd == retFn;\r\n            }\r\n            return newTd;\r\n        };\r\n\r\n        if (tdColIndex == 0) {\r\n            this.forEachRow((row, rowIndex) => {\r\n                this.nanny.insertBeforeTd(row, this.nanny.getTdInRow(row, 0), newInsertTd(rowIndex, tdColIndex, row));\r\n            });\r\n        } else {\r\n            const tdDone = [];\r\n            const matrix = this.getTdMatrix(beforeThisTd);\r\n            this.forEachRow((row, indexRow) => {\r\n                const td = this.getTdByMatrix(indexRow, matrix[1] - 1);\r\n                if (tdDone.indexOf(td) == -1) {\r\n                    if (this.cellType(td) == this.CELL_NORMAL) {\r\n                        this.nanny.insertAfterTd(this.nanny.getRowByTd(this.dom, td), td, newInsertTd(indexRow, tdColIndex, row));\r\n                    } else {    // big cell\r\n                        this.nanny.setTdSpan(td, null, 1, true);\r\n                    }\r\n                    tdDone.push(td);\r\n                }\r\n            });\r\n        }\r\n        this.refresh();\r\n        return this;\r\n    }\r\n};"," // utils, a dog always hardworing.\r\n\r\nexport default {\r\n    tableClassName: '_table-butcher_',\r\n    init(table){\r\n        this.dom = table;\r\n    },\r\n    initObj(obj) {\r\n        this.dom = obj;\r\n    },\r\n\r\n    getSpan(td){\r\n        return [this.nanny.getTdRowSpan(td), this.nanny.getTdColSpan(td)];\r\n    },\r\n\r\n\r\n    getTdIndex(td){\r\n        if (!td) return;\r\n        const tr = this.nanny.getRowByTd(this.dom, td);\r\n        let rowIndex = -1,\r\n            colIndex = -1;\r\n        this.forEachRow((row, index)=>{\r\n            if (row === tr){\r\n                rowIndex = index;\r\n                return true;\r\n            }\r\n        });\r\n\r\n        const tds = this.nanny.getTdsInRow(tr);\r\n        tds.forEach((val, index)=>{\r\n            if (val === td){\r\n                colIndex = index;\r\n            }\r\n        });\r\n\r\n        return [rowIndex, colIndex];\r\n    },\r\n\r\n    getTdByIndex(tdRow, tdCol){\r\n        if (tdRow == -1 || tdCol == -1){\r\n            return null;\r\n        }\r\n        let inRow = -1, retTd;\r\n        this.forEachRow((row, index)=>{\r\n            if (tdRow == index){\r\n                inRow = row;\r\n                return true;\r\n            }\r\n        });\r\n        if (inRow == -1){\r\n            return null;\r\n        }else{\r\n            // retTd = inRow.querySelectorAll(':scope > td')[tdCol];\r\n            retTd = this.nanny.getTdsInRow(inRow)[tdCol];\r\n            return retTd;\r\n        }\r\n    },\r\n\r\n    getTdMatrix(td) {\r\n        return this.matrixTd2Mat(...this.getTdIndex(td));\r\n    },\r\n\r\n    getTdByMatrix(matRow, matCol){\r\n        return this.getTdByIndex(...this.matrixMat2Td(matRow, matCol));\r\n    },\r\n\r\n    /**\r\n     * calculate table rectangle size\r\n     */\r\n    getSize(){\r\n        let sizeCol = 0, me = this, allTdSize=[];\r\n        // find max column size\r\n        this.forEachRow((row, rowIndex)=>{\r\n            let thisRowSize = 0;\r\n            this.nanny.getTdsInRow(row).forEach((td, colIndex)=>{\r\n                let span = me.getSpan(td);\r\n                thisRowSize += span[1];\r\n            });\r\n            allTdSize.push(thisRowSize);\r\n        });\r\n        if (allTdSize.length > 0) {\r\n            sizeCol = Math.max(...allTdSize);\r\n        }\r\n        // this.forUnderTable( (td)=>{\r\n        //     let span = me.getSpan(td);\r\n        //     sizeCol += span[1];\r\n        // }, '> tr:first-child > td');\r\n        return [\r\n            this.nanny.getRowSize(this.dom),\r\n            sizeCol\r\n        ];\r\n    },\r\n\r\n    /**\r\n     * sort row by row\r\n     * @param {Array[TD]} tds \r\n     */\r\n    sort(arrTd){\r\n        let me = this;\r\n        arrTd.sort((a,b)=>{\r\n            let aPos = me.getTdIndex(a), // Do not mind.\r\n                bPos = me.getTdIndex(b); // Do not mind.\r\n            if (aPos[0] != bPos[0]){\r\n                return aPos[0] - bPos[0];\r\n            }else{\r\n                return aPos[1] - bPos[1];\r\n            }\r\n        })\r\n        return arrTd;\r\n    },\r\n\r\n    /**\r\n     * loop each td with tr and position detail\r\n     */\r\n    forEachCell(fn){\r\n        const fnTR = (tr, rowIndex)=>{\r\n            let tds = this.nanny.getTdsInRow(tr),\r\n                colIndex = 0;\r\n            for(let td of tds){\r\n                fn(td, rowIndex, colIndex, tr);\r\n                colIndex++;\r\n            }\r\n        };\r\n        // this.forUnderTable(fnTR, '> tr');\r\n        this.forEachRow(fnTR);\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param {fn}  receive arguments(element, index, all elements)\r\n     */\r\n    forEachRow(fn){\r\n        this.nanny.eachRow(this.dom, fn);\r\n    },\r\n\r\n\r\n    /**\r\n     * loop under the table\r\n     */\r\n    // forUnderTable(fn, selector = '> tr > td'){\r\n    //     let elements = this.dom.querySelectorAll(`:scope > tbody ` + selector);\r\n    //     let index = -1;\r\n    //     for(let el of elements){\r\n    //         index++;\r\n    //         if (true === fn(el, index, elements)){\r\n    //             return;\r\n    //         }\r\n    //     }\r\n    // },\r\n\r\n    /**\r\n     * loop with table matrix\r\n     * @param {function}    fn      invoke with argument (express number, row index, column index, row array)\r\n     */\r\n    forEachMatrix(fn){\r\n        let indexOfRow = -1,\r\n            indexOfCol = -1;\r\n        for(let row of this.matrix){\r\n            indexOfRow++;\r\n            indexOfCol = -1;\r\n            for(let col of row){\r\n                indexOfCol++;\r\n                if(true === fn(col, indexOfRow, indexOfCol, row)){\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * find the first same expression number in table matrix\r\n     * @param {integer} expNumber\r\n     */\r\n    findFirstTime(expNumber){\r\n        let ret = null;\r\n        this.forEachMatrix((val, row, col, arr)=>{\r\n            if (val === expNumber){\r\n                ret = [row, col];\r\n                return true;\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n};","export default {\r\n\tnewTd: () => document.createElement('td'),\r\n\tdelTd: (row, td) => row.removeChild(td),\r\n\tnewTr: () => document.createElement('tr'),\r\n\tdelTr: (table, row) => table.childNodes[0].removeChild(row),\r\n\r\n\tgetTdRowSpan: (obj) => obj.rowSpan,\r\n\tgetTdColSpan: (obj) => obj.colSpan,\r\n\tgetRowByIndex: (table, index) => table.childNodes[0].childNodes[index],\r\n\tgetRowByTd(table, td){\r\n\t\tlet ret = null;\r\n\t\tthis.eachRow(table, (row) => {\r\n\t\t\tconst index = Array.prototype.indexOf.call(row.childNodes, td);\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tret = row\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn ret;\r\n\t},\r\n\t// return array\r\n\tgetTdsInRow: (row) => row.childNodes,\r\n\tgetTdInRow: (row, index) => row.childNodes[index],\r\n\tgetRowSize: (table) => {\r\n\t\tif (table && table.childNodes && table.childNodes.length > 0) {\r\n\t\t\treturn table.childNodes[0].childNodes.length;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t},\r\n\teachRow:(table, fn) => {\r\n\t\tif (table && table.childNodes && table.childNodes.length > 0) {\r\n\t\t\ttable.childNodes[0].childNodes.forEach(fn)\r\n\t\t}\r\n\t},\r\n\r\n\tinsertEmptyRow: (table, index) => table.insertRow(index),\r\n\tinsertRowBefore: (table, row, newRow) => row.before(newRow),\r\n\tinsertBeforeTd: (row, td, newEl) => td.before(newEl),\r\n\tinsertAfterTd: (row, td, newEl) => td.after(newEl),\r\n\tappendTd: (tr, el) => tr.appendChild(el),\r\n\tmoveTdChilds: (tdSource, tdTarget) => {\r\n\t\tif (!tdSource || !tdSource.childNodes || tdSource.childNodes.length == 0) { return }\r\n\t\ttdSource.childNodes.forEach(node => tdTarget.append(node))\r\n\t},\r\n\r\n\t/**\r\n\t * @param {Element} td \t\t\tTD\r\n\t * @param {Number} rowSpan \t\ttd rowSpanoffset=truerowSpan\r\n\t * @param {Number} colSpan \t\ttd colSpanoffset=truecolSpan\r\n\t * @param {Boolean} offset \t\t\r\n\t */\r\n\tsetTdSpan(td, rowSpan, colSpan, offset = false){\r\n\t\tif (rowSpan !== null) {\r\n\t\t\tif (offset) {\r\n\t\t\t\ttd.rowSpan += rowSpan;\r\n\t\t\t} else {\r\n\t\t\t\ttd.rowSpan = rowSpan;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (colSpan !== null) {\r\n\t\t\tif (offset) {\r\n\t\t\t\ttd.colSpan += colSpan;\r\n\t\t\t} else {\r\n\t\t\t\ttd.colSpan = colSpan;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn td;\r\n\t}\r\n}\r\n\r\n/*\r\nfix keyword:\r\ncolSpan, rowSpan,\r\nparentNode\r\nappendChild, append\r\nbefore, after\r\ndocument, createElement\r\n*/","import father from './father';\r\nimport mother from './mother';\r\nimport liLei from './liLei';\r\nimport hanMeiMei from './hanMeiMei';\r\nimport puppy from './puppy';\r\nimport nannyDom from './nannyDom';\r\n\r\n// output layer\r\nlet diapason = {\r\n    dom: null,\r\n    ...father,\r\n    ...mother,\r\n    ...liLei,\r\n    ...hanMeiMei,\r\n    ...puppy\r\n};\r\n\r\n// entry class\r\nconst TableBuster = function(table){ \r\n    this.nanny = nannyDom;\r\n    this.init(table);\r\n    this.buildMatrix();\r\n};\r\nconst TableObjectBuster = function (nannyObj) {\r\n    this.nanny = nannyObj;\r\n    this.init = function(object) {\r\n        this.initObj(object);\r\n        this.buildMatrix();\r\n    };\r\n};\r\n// Object.assign(diapason, father, mother, liLei, hanMeiMei, puppy);\r\nTableBuster.prototype = diapason;\r\nTableObjectBuster.prototype = diapason;\r\n\r\nexport { TableObjectBuster, TableBuster };\r\n\r\nwindow.TableBuster = TableBuster;\r\nwindow.TableObjectBuster = TableObjectBuster;\r\n// export default TableBuster;"]}